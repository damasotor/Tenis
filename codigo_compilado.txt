--- INICIO DE ARCHIVO: main.py ---
import os
import sys
import pygame
from engine.game import Game

if __name__ == "__main__":
    # Fijar el directorio de trabajo al del archivo (rutas relativas estables)
    os.chdir(os.path.dirname(os.path.abspath(__file__)))

    # Inicializar Pygame (audio y video)
    pygame.init()
    
    try:
        game = Game()
        game.game_loop()
    except Exception as e:
        # Log simple a stderr para depurar si algo truena
        print(f"[ERROR] {e}", file=sys.stderr)
        raise
    finally:
        pygame.quit()

--- FIN DE ARCHIVO: main.py ---

--- INICIO DE ARCHIVO: engine/audio.py ---
import pygame
import random

class AudioManager:
    """
    Gestor de audio centralizado.
    - Grupos con volumen: ui / sfx / amb / music
    - Variantes: register_variants("hit_racket", "hit_racket2", "hit_racket3")
    - Paneo est√©reo por evento: play_sound_panned("bounce_court", pan=-1..+1)
    - Ducking simple de m√∫sica: duck_music(down_to=0.15) / unduck_music()
    - Cooldowns por SFX para evitar spam

    Novedades:
    - Helper load_net_sfx() para cargar:
        ‚Ä¢ assets/audio/net_tape.wav  (cinta)
        ‚Ä¢ assets/audio/net_body.wav  (cuerpo)
    - Mute global reversible:
        ‚Ä¢ mute_all() / unmute_all() / toggle_mute_all() / is_all_muted()
    """

    def __init__(self, num_channels=16):
        try:
            pygame.mixer.pre_init(44100, -16, 2, 512)
            pygame.mixer.init()
            pygame.mixer.set_num_channels(num_channels)
            self.enabled = True
        except pygame.error as e:
            print(f"[Audio] Deshabilitado: {e}")
            self.enabled = False

        # name -> (Sound, group, base_volume)
        self.sounds = {}
        # base_name -> [variant_names] (incluye el base)
        self.variants = {}
        # name -> ms (tiempo m√≠nimo entre reproducciones del mismo name)
        self.cooldowns = {}
        # name -> last_ticks
        self.last_played = {}

        self.music_path = None
        self._duck_prev = None  # guarda el volumen previo de m√∫sica durante duck

        # Vol√∫menes por grupo (0..1)
        self.group_vol = {
            "ui":    0.70,
            "sfx":   0.85,
            "amb":   0.25,  # si us√°s ambiente como m√∫sica, ajustar√°s con play_music
            "music": 0.40,
        }

        # --- Estado de mute global ---
        self._muted_all = False
        self._saved_group_vols = {}

    # ---------------------------
    # Carga
    # ---------------------------
    def load_sound(self, name, path, volume=0.8, group="sfx", cooldown_ms=0):
        """
        Carga un sonido. Firma compatible con tu versi√≥n anterior:
        load_sound(name, path, volume=0.8)
        (ahora opcionalmente pod√©s indicar group y cooldown_ms)
        """
        if not self.enabled:
            return
        try:
            s = pygame.mixer.Sound(path)
            s.set_volume(max(0.0, min(1.0, float(volume))))
            self.sounds[name] = (s, group, float(volume))
            if cooldown_ms > 0:
                self.cooldowns[name] = int(cooldown_ms)
        except pygame.error as e:
            print(f"[Audio] Error cargando '{name}' desde '{path}': {e}")

    def register_variants(self, base_name, *names):
        """
        Registra variantes para que al pedir 'base_name' elija una al azar.
        Ej: register_variants('hit_racket', 'hit_racket2', 'hit_racket3')
        """
        self.variants[base_name] = [base_name] + [n for n in names if n in self.sounds]

    def load_music(self, path):
        if not self.enabled:
            return
        self.music_path = path

    # Conveniencia: cargar SFX de la red (cinta/cuerpo)
    def load_net_sfx(self,
                     tape_path="assets/audio/net_tape.wav",
                     body_path="assets/audio/net_body.wav"):
        """
        Carga los SFX de la red:
          - net_tape  ‚Üí golpe en la cinta (brillante, corto)
          - net_body  ‚Üí golpe en el cuerpo (grave, amortiguado)
        """
        # Vol√∫menes recomendados y cooldown para evitar spam en rebotes m√∫ltiples
        self.load_sound("net_tape", tape_path, volume=0.80, group="sfx", cooldown_ms=70)
        self.load_sound("net_body", body_path, volume=0.90, group="sfx", cooldown_ms=70)

    # ---------------------------
    # M√∫sica
    # ---------------------------
    def play_music(self, loops=-1, volume=None):
        """
        Reproduce m√∫sica con el volumen indicado o, si volume es None,
        usa el volumen del grupo 'music'.
        """
        if not (self.enabled and self.music_path):
            return
        try:
            pygame.mixer.music.load(self.music_path)
            if volume is None:
                vol = self.group_vol["music"]
            else:
                vol = max(0.0, min(1.0, float(volume)))
            pygame.mixer.music.set_volume(vol)
            pygame.mixer.music.play(loops)
        except pygame.error as e:
            print(f"[Audio] Error al reproducir m√∫sica '{self.music_path}': {e}")

    def stop_music(self):
        if not self.enabled:
            return
        pygame.mixer.music.stop()

    def fadeout_music(self, ms=600):
        if not self.enabled:
            return
        pygame.mixer.music.fadeout(int(ms))

    # Ducking: baja temporalmente la m√∫sica a un valor absoluto
    def duck_music(self, down_to=0.15):
        if not self.enabled:
            return
        # guarda el volumen previo (solo la primera vez hasta unduck)
        if self._duck_prev is None:
            self._duck_prev = pygame.mixer.music.get_volume()
        pygame.mixer.music.set_volume(max(0.0, min(1.0, float(down_to))))

    def unduck_music(self):
        if not self.enabled:
            return
        # restaura el volumen previo si lo ten√≠amos, si no usa el del grupo
        if self._duck_prev is not None:
            pygame.mixer.music.set_volume(self._duck_prev)
            self._duck_prev = None
        else:
            pygame.mixer.music.set_volume(self.group_vol.get("music", 0.4))

    def set_group_volume(self, group, volume):
        """
        Ajusta el volumen de un grupo (0..1).
        Para 'music' aplica inmediatamente.
        """
        v = max(0.0, min(1.0, float(volume)))
        self.group_vol[group] = v
        if group == "music":
            pygame.mixer.music.set_volume(v)

    # ---------------------------
    # Mute global
    # ---------------------------
    def mute_all(self):
        """Silencia todos los grupos (ui/sfx/amb/music) guardando vol√∫menes previos."""
        if not self.enabled or self._muted_all:
            return
        # Guardar mezcla actual
        self._saved_group_vols = dict(self.group_vol)
        # Llevar todo a 0 (incluye m√∫sica)
        for g in list(self.group_vol.keys()):
            self.set_group_volume(g, 0.0)
        self._muted_all = True

    def unmute_all(self):
        """Restaura los vol√∫menes guardados con mute_all()."""
        if not self.enabled or not self._muted_all:
            return
        # Restaurar mezcla anterior
        if self._saved_group_vols:
            for g, v in self._saved_group_vols.items():
                self.set_group_volume(g, v)
        self._saved_group_vols = {}
        self._muted_all = False

    def toggle_mute_all(self):
        """Atajo para alternar mute global."""
        if self._muted_all:
            self.unmute_all()
        else:
            self.mute_all()

    def is_all_muted(self) -> bool:
        return bool(self._muted_all)

    # ---------------------------
    # Reproducci√≥n de SFX
    # ---------------------------
    def _pick_variant(self, name):
        vs = self.variants.get(name)
        if vs:
            # filtrar por si alguna variante se removi√≥
            vs = [n for n in vs if n in self.sounds]
            if vs:
                return random.choice(vs)
        return name

    def _can_play(self, name):
        cd = self.cooldowns.get(name)
        if not cd:
            return True
        now = pygame.time.get_ticks()
        last = self.last_played.get(name, -10**9)
        return (now - last) >= cd

    def _mark_played(self, name):
        self.last_played[name] = pygame.time.get_ticks()

    def _effective_vol(self, group, base_volume):
        """
        Volumen efectivo = volumen base del sample * volumen del grupo.
        """
        g = self.group_vol.get(group, 1.0)
        return max(0.0, min(1.0, float(base_volume) * g))

    def play_sound(self, name, loops=0):
        """Reproduce un SFX (usa variantes y cooldown si est√°n configurados)."""
        if not self.enabled or self._muted_all:
            return
        key = self._pick_variant(name)
        if not self._can_play(key):
            return
        pak = self.sounds.get(key)
        if not pak:
            return
        snd, group, base_vol = pak
        # Si el grupo est√° en 0, evitamos buscar canal innecesariamente
        if self._effective_vol(group, base_vol) <= 0.0:
            return
        ch = pygame.mixer.find_channel()
        if ch:
            ch.set_volume(self._effective_vol(group, base_vol))
            ch.play(snd, loops=loops)
            self._mark_played(key)

    def play_sound_panned(self, name, pan=0.0):
        """
        Reproduce un SFX con paneo est√©reo:
        pan = -1.0 (izq) ... 0 (centro) ... +1.0 (der)
        """
        if not self.enabled or self._muted_all:
            return
        key = self._pick_variant(name)
        if not self._can_play(key):
            return
        pak = self.sounds.get(key)
        if not pak:
            return
        snd, group, base_vol = pak
        vol = self._effective_vol(group, base_vol)
        if vol <= 0.0:
            return

        ch = pygame.mixer.find_channel()
        if not ch:
            return

        pan = max(-1.0, min(1.0, float(pan)))
        # Distribuci√≥n simple en L/R
        left = vol * (1.0 - max(0.0, pan))    # si pan > 0 reduce L
        right = vol * (1.0 - max(0.0, -pan))  # si pan < 0 reduce R
        ch.set_volume(left, right)
        ch.play(snd)
        self._mark_played(key)

--- FIN DE ARCHIVO: engine/audio.py ---

--- INICIO DE ARCHIVO: engine/ball.py ---
import os
import json
import math
import random
import collections
from typing import Optional, List, Tuple

import pygame

# Asumimos que estas est√°n definidas en otro lado
try:
    from engine.utils.screen import ALTO, ANCHO, screen_to_world
except ImportError:
    # Fallback para que el c√≥digo sea runnable de forma aislada
    ANCHO, ALTO = 800, 600
    def screen_to_world(x, y): return x, y

TrailPoint = Tuple[int, int]
FrameRect = Tuple[int, int, int, int]

# Par√°metros f√≠sicos (fallbacks)
SPIN_GRAVITY_SCALE, SPIN_DRIFT_SCALE, SPIN_DECAY = 0.12, 0.06, 0.96

def world_to_iso(x: float, y: float, z: float = 0.0) -> Tuple[float, float]:
    """
    Convierte coordenadas del mundo (x, y, z) a coordenadas de pantalla isom√©tricas.
    """
    iso_x = x - y
    iso_y = (x + y) * 0.5 - z
    return iso_x, iso_y

# Par√°metros f√≠sicos
GRAVEDAD = -0.5
COEF_REBOTE = 0.7
FACTOR_ISO_X = 0.5    # qu√© tanto se "desplaza" la sombra en X por altura
FACTOR_ISO_Y = 0.3    # qu√© tanto se "desplaza" la sombra en Y por altura

class Ball(pygame.sprite.Sprite):
    """
    Pelota con f√≠sica 3D/isom√©trica.
    """
    def __init__(self, x: int, y: int, game, vx: float, vy: float):
        super().__init__()
        self.game = game

        # Posici√≥n base (x, y) en el mundo (suelo)
        self.x = x
        self.y = y
        # Altura en el eje vertical (z)
        self.z = 80
        
        # üîë CORRECCI√ìN: Usar las velocidades iniciales pasadas
        self.vx = vx
        self.vy = vy
        self.vz = 0.0 # Impulso vertical inicial
        
        # Propiedades f√≠sicas/visuales
        self.radio = 7
        self.spin = 0.0 # Spin (topspin > 0, backspin < 0)
        
        # Sprite de fallback (c√≠rculo simple)
        self.image = pygame.Surface((self.radio * 2, self.radio * 2), pygame.SRCALPHA)
        pygame.draw.circle(self.image, (255, 255, 255), (self.radio, self.radio), self.radio)
        self.rect = self.image.get_rect()
        
        # Estado de colisi√≥n de red
        self._net_cd_ms = 100        # Cooldown para evitar rebotes m√∫ltiples en la red
        self._last_net_hit = -10**9  # Marca de tiempo del √∫ltimo golpe a la red
        
        # Estado del juego
        self.is_serving = False
        self.serve_stage = None   # "toss", "falling", "served", "fault", "ready"
        self.server = None
        self.bounce_count = 0
        self.waiting_hit = False
        self.out_of_bounds = False

        # Propiedades visuales
        self._squash_timer = 0
        self._squash_duration = 5

    @property
    def screen_x(self) -> float:
        iso_x, _ = world_to_iso(self.x, self.y, self.z)
        # centramos en la pantalla
        return iso_x + ANCHO // 2

    @property
    def screen_y(self) -> float:
        _, iso_y = world_to_iso(self.x, self.y, self.z)
        # bajamos un poco para centrar cancha visualmente
        return iso_y + ALTO // 3

    # ... (Se omite _load_sprite_or_fallback por simplicidad si no hay assets) ...
    def _load_sprite_or_fallback(self):
        r = 8
        self.image = pygame.Surface((r*2, r*2), pygame.SRCALPHA)
        pygame.draw.circle(self.image, (250, 250, 250), (r, r), r)
        self.rect = self.image.get_rect()
        self._use_sprite = False
    
    # ----------------- API -----------------
    def start_rally(self):
        if hasattr(self.game, "audio"):
            # L√≥gica de audio (ducking, sonido de saque)
            pass

    def apply_shot_spin(self, spin_value: float):
        """Se llama desde Player al impactar: setea spin inicial del tiro."""
        self.spin = float(spin_value)

    # ----------------- Helpers audio -----------------
    def _calc_pan(self) -> float:
        W = self.game.PANTALLA.get_width()
        x = self.rect.centerx
        return (x / max(1, W)) * 2.0 - 1.0


    def launch_toward_zone(self, zone: str = None, speed: float = 5.0):
        # ... (L√≥gica de lanzamiento, se mantiene igual) ...
        if zone is None:
            zone = random.choice(["izquierda", "centro", "derecha"])

        if zone == "izquierda":
            dir_x, dir_y = -1, 1
        elif zone == "derecha":
            dir_x, dir_y = 1, 1
        else:
            dir_x, dir_y = 0, 1

        length = (dir_x**2 + dir_y**2) ** 0.5
        self.vx = (dir_x / length) * speed
        self.vy = (dir_y / length) * speed

        self.vz = speed * 0.6
        print(f"[DEBUG] Lanzamiento hacia {zone}: vx={self.vx:.2f}, vy={self.vy:.2f}, vz={self.vz:.2f}")
    
    def launch_toward_random_zone(self):
        # ... (L√≥gica de lanzamiento, se mantiene igual) ...
        zones = [
            (random.uniform(100, 400), random.uniform(100, 200)),
            (random.uniform(400, 700), random.uniform(100, 200)),
            (random.uniform(100, 400), random.uniform(300, 500)),
            (random.uniform(400, 700), random.uniform(300, 500)),
        ]
        target_x, target_y = random.choice(zones)

        dx = target_x - self.x
        dy = target_y - self.y
        dist = (dx ** 2 + dy ** 2) ** 0.5

        self.vx = dx / dist * random.uniform(4.5, 6.0)
        self.vy = dy / dist * random.uniform(4.5, 6.0)
        self.vz = -random.uniform(6.0, 9.0)

        print(f"Lanzando hacia zona ({target_x:.1f}, {target_y:.1f}) con vx={self.vx:.2f}, vy={self.vy:.2f}, vz={self.vz:.2f}")
    
    # ----------------- Eventos -----------------
    def _trigger_squash(self):
        self._squash_timer = self._squash_duration

    # ... (M√©todos on_racket_hit, on_body_hit, on_out, on_point_scored se mantienen igual) ...

    def _on_bounce_court(self):
        if hasattr(self.game, "audio"):
            # L√≥gica de audio
            pass
        self._trigger_squash()

    def on_racket_hit(self):
        if hasattr(self.game, "audio"):
            # L√≥gica de audio
            pass

        AMORTIGUACION = 0.65
        self.vy *= -1
        self.vx *= AMORTIGUACION
        self.vy *= AMORTIGUACION

        MIN_VEL_AFTER_HIT = 3.0
        if abs(self.vy) < MIN_VEL_AFTER_HIT:
            self.vy = MIN_VEL_AFTER_HIT * (1 if self.vy >= 0 else -1)

        self._trigger_squash()

    def on_body_hit(self):
        if hasattr(self.game, "audio"):
            # L√≥gica de audio
            pass

        DEAD_BOUNCE_FACTOR = 0.25
        self.vx *= -DEAD_BOUNCE_FACTOR
        self.vy *= -DEAD_BOUNCE_FACTOR
        self._trigger_squash()

        self.on_point_scored()

        try:
            last = getattr(self.game, "last_hitter", None)
            if last == "P1":
                self.game.point_for("P2")
            elif last == "P2":
                self.game.point_for("P1")
            else:
                self.game.point_for("P2")
        except Exception:
             pass

    def on_out(self):
        if hasattr(self.game, "audio"):
            # L√≥gica de audio si queres
            pass
        
        last = getattr(self.game, "last_hitter", None)
        if hasattr(self.game, "point_for"):
            if last == "P1":
                self.game.point_for("P2")
            elif last == "P2":
                self.game.point_for("P1")
            else:
                self.game.point_for("P2")

    def on_point_scored(self):
        if hasattr(self.game, "audio"):
            # L√≥gica de audio si queres y sino bueno
            pass

    def prepare_for_serve(self, server, x, y):
        """Coloca la pelota lista para ser servida, sin movimiento."""
        self.is_serving = True
        self.serve_stage = "ready"
        self.server = server
        
        world_x, world_y = screen_to_world(x, y)
        self.x = world_x
        self.y = world_y

        self.z = 0
        self.vx = self.vy = self.vz = 0
        print(f"üéæ Pelota lista para saque de {server} en ({self.x:.1f}, {self.y:.1f})")

    # ----------------- L√≥gica de saque (toss y golpe) -----------------
    def start_toss(self, server_id: str, start_x: float, start_y: float):
        self.server_id = server_id
        self.x = start_x
        self.y = start_y
        print("Posicion pelota: ", self.x, self.y)
        self.z = 0
        self.vx = 0
        self.vy = 0
        self.vz = 10
        self.serve_stage = "toss"
        self.waiting_hit = True
        self.out_of_bounds = False
        print(f"üéæ Toss iniciado por {server_id} en ({start_x:.1f}, {start_y:.1f})")

    def update_toss(self):
        """
        Actualiza la f√≠sica del lanzamiento de saque (toss).
        """
        self.z += self.vz
        self.vz -= 0.6

        if self.vz <= 0 and self.serve_stage == "toss":
            self.serve_stage = "falling"
            print("‚¨áÔ∏è La pelota empieza a caer...")

        if self.z <= 0 and self.waiting_hit:
            self.z = 0
            self.vz = 0
            self.waiting_hit = False
            self.serve_stage = "fault"
            print("‚ùå Saque fallido (la pelota cay√≥ sin ser golpeada)")
            if hasattr(self.game, "audio"):
                # L√≥gica de audio para falta
                pass

    def update(self):
        # --------------------------
        # ETAPAS DEL SAQUE
        # --------------------------
        if getattr(self, "serve_stage", None) in ("toss", "falling"):
            self.update_toss()
            iso_x, iso_y = world_to_iso(self.x, self.y, self.z)
            self.rect.center = (iso_x + ANCHO // 2, iso_y + ALTO // 3)
            return

        if self.serve_stage == "ready":
            iso_x, iso_y = world_to_iso(self.x, self.y, self.z)
            self.rect.center = (iso_x + ANCHO // 2, iso_y + ALTO // 3)
            return

        if self.serve_stage == "fault":
            # Si es falta, se queda quieta en el suelo
            return

        # ===== Movimiento en el mundo =====
        self.x += self.vx
        self.y += self.vy
        self.z += self.vz

        # Gravedad y rebote vertical
        self.vz -= 0.5
        if self.z <= 0:
            self.z = 0
            self.vz = -self.vz * 0.7
            if abs(self.vz) < 0.8:
                self.vz = 0

        # ===== L√≠mites del campo (Out) =====
        FIELD_LEFT = -50
        FIELD_RIGHT = 250
        FIELD_TOP = -150
        FIELD_BOTTOM = 350

        if self.z == 0 and not self.out_of_bounds:
            # Chequear OUT solo despu√©s de un pique
            if self.x < FIELD_LEFT or self.x > FIELD_RIGHT or self.y < FIELD_TOP or self.y > FIELD_BOTTOM:
                self.out_of_bounds = True
                self.on_out() # Llama a la l√≥gica de punto

        # üîë CORRECCI√ìN CR√çTICA: L√≥gica de colisi√≥n de red movida de draw() a update()
        if hasattr(self.game, "field") and self.z > 0: # Solo chequear si est√° en el aire
            net = self.game.field.net
            now = pygame.time.get_ticks()

            if now >= self._last_net_hit + self._net_cd_ms:
                if self.game.field.net.ball_hits_net((self.x, self.y, self.z), self.radio):
                    self._last_net_hit = now

                    # 1. Aplicar rebote y amortiguaci√≥n
                    self.vx = 0.0 # Detiene el movimiento lateral (eje X)
                    self.vy = 0.0 # Detiene el movimiento de profundidad (eje Y)
                    self.vz *= 0.2

                    # 2. Reajuste Geom√©trico (Mover la pelota fuera del obst√°culo)
                    net_y_pos = 105.0 
                    CLEARANCE = 5.0 

                    if self.y > net_y_pos:
                        # Si est√° en el lado Y positivo (P1), empujar hacia su lado (m√°s positivo Y)
                        self.y = net_y_pos + self.radio + CLEARANCE
                    else:
                        # Si est√° en el lado Y negativo (P2), empujar hacia su lado (m√°s negativo Y)
                        self.y = net_y_pos - (self.radio + CLEARANCE)
                        
                    print(f"üî¥ Rebote en la red. Posici√≥n final (x,y,z): ({self.x:.2f}, {self.y:.2f}, {self.z:.2f})")
        # --------------------------------------------------------------------------

        # ===== Convertir a pantalla =====
        iso_x, iso_y = world_to_iso(self.x, self.y, self.z)
        self.rect.center = (iso_x + ANCHO // 2, iso_y + ALTO // 3)

    def draw(self, screen):
        # Sombra proyectada (m√°s cerca del suelo)
        sombra_x, sombra_y = world_to_iso(self.x, self.y, 0)
        sombra_x += ANCHO // 2
        sombra_y += ALTO // 3
        
        # El tama√±o de la sombra se reduce con la altura
        sombra_radio = max(1, self.radio - int(self.z * 0.05))
        sombra_color = (50, 50, 50, max(0, 150 - int(self.z * 1.5))) # Transparencia seg√∫n altura

        sombra_surf = pygame.Surface((sombra_radio * 2, sombra_radio * 2), pygame.SRCALPHA)
        pygame.draw.circle(sombra_surf, sombra_color, (sombra_radio, sombra_radio), sombra_radio)
        
        screen.blit(sombra_surf, (int(sombra_x - sombra_radio), int(sombra_y - sombra_radio)))

        # Pelota (m√°s alta seg√∫n z)
        px, py = self.screen_x, self.screen_y
        pygame.draw.circle(screen, (255, 255, 0), (int(px), int(py)), self.radio)
        
    def hit_by_player(self, player_pos, zone="center", is_player2=False):
        if getattr(self, "serve_stage", None) in ("toss", "falling"):
            self.waiting_hit = False
            self.serve_stage = "served"
            self.start_rally()

        field = self.game.field
        
        if zone not in field.zones:
            print(f"[‚ö†Ô∏è] Zona '{zone}' no encontrada, usando centro por defecto.")
            target_x, target_y = 0, 0
        else:
            zx, zy, zw, zh = field.zones[zone]

            target_x = zx + random.uniform(0.2, 0.8) * zw
            target_y = zy + random.uniform(0.2, 0.8) * zh

        # --- Calcular direcci√≥n del golpe ---
        dx = target_x - self.x
        dy = target_y - self.y
        # dz = 0 - self.z # Eliminamos esto, el golpe ya se encarga de la altura

        dist = math.sqrt(dx**2 + dy**2)
        if dist == 0:
            dist = 1e-5

        # --- Ajustar fuerza y velocidad del golpe ---
        base_speed = random.uniform(8, 11)

        horizontal_boost = 1.5 if base_speed < 9 else 1.0

        self.vx = (dx / dist) * base_speed * horizontal_boost
        self.vy = (dy / dist) * base_speed * horizontal_boost

        # Altura suficiente para pasar la red
        self.vz = random.uniform(6, 8)

        print(f"üéæ Golpe de {'P2' if is_player2 else 'P1'} hacia '{zone}' ‚Üí ({target_x:.1f}, {target_y:.1f}) con vx={self.vx:.2f}, vy={self.vy:.2f}, vz={self.vz:.2f}")

--- FIN DE ARCHIVO: engine/ball.py ---

--- INICIO DE ARCHIVO: engine/field.py ---
import os
import random
from typing import Optional, Tuple

import pygame

from engine.ball import world_to_iso
from engine.net import Net
from engine.utils import screen
from engine.utils.screen import to_pixels, world_to_screen, ANCHO, ALTO, SCALE

# Loader de texturas con fallback seguro
try:
    from engine.assets.texture_loader import load_texture as _load_texture
except Exception:
    _load_texture = None


def compute_offset(field_width: float, field_height: float, scale: float) -> Tuple[int, int]:
    """
    Calcula el desplazamiento (offset) necesario para centrar la cancha
    en la pantalla, seg√∫n su tama√±o en coordenadas del mundo e isom√©tricas.
    """
    # Calcular las esquinas en coordenadas isom√©tricas
    corners_iso = [
        world_to_screen(0, 0),
        world_to_screen(field_width, 0),
        world_to_screen(field_width, field_height),
        world_to_screen(0, field_height),
    ]

    # Escalar las coordenadas al tama√±o visual del juego
    corners_scaled = [(iso_x * scale, iso_y * scale) for iso_x, iso_y in corners_iso]

    # Determinar el √°rea (bounding box) que ocupa la cancha en pantalla
    min_x = min(c[0] for c in corners_scaled)
    max_x = max(c[0] for c in corners_scaled)
    min_y = min(c[1] for c in corners_scaled)
    max_y = max(c[1] for c in corners_scaled)

    # Calcular el centro del √°rea ocupada
    center_x = (min_x + max_x) / 2
    center_y = (min_y + max_y) / 2

    # Offset necesario para centrar la cancha en la pantalla
    offset_x = ANCHO // 2 - int(center_x)
    offset_y = ALTO // 2 - int(center_y)
    return offset_x, offset_y


class Field:
    def __init__(self, width: int, height: int, texture_path: Optional[str] = None):
        self.width = width
        self.height = height

        # === L√≠mites y centro del campo (coordenadas l√≥gicas del mundo) ===
        self.left = 0
        self.top = 0
        self.right = width
        self.bottom = height
        self.center_x = self.left + self.width / 2
        self.center_y = self.top + self.height / 2

        # net
        self.net_y = (height // 2) + 64
        self.net_height = 50
        self.net = Net(self)

        # --- Zonas l√≥gicas (mundo) ---
        self.zones = {
            "deep_back_left": (-45, 230, 150, 125),
            "back_left":  (-45, 105, 150, 125),
            "deep_front_left": (-45, -145, 150, 125),
            "front_left": (-45, -20, 150, 125),
            "deep_front_right": (105, -145, 150, 125),
            "front_right": (105, -20, 150, 125),
            "deep_back_right": (105, 230, 150, 125),
            "back_right": (105, 105, 150, 125),
            "center_back": (30, 105, 150, 250),
            "center_front": (30, -145, 150, 250),
        }

        # Offset de centrado
        self.offset_x, self.offset_y = compute_offset(width, height, SCALE)

        # Factor de escala visual para la textura
        self.scale_factor = 0.8

        # Cache de court rect del √∫ltimo draw
        self._last_court_rect: Optional[pygame.Rect] = None

        # Debug opcional (pod√©s setearlo desde Game)
        self.debug = False

        # -------- Textura de fondo de la cancha --------
        # Soportamos ruta custom (texture_path) o tu ruta por defecto en espa√±ol.
        if texture_path:
            base = os.path.join("assets", "textures")
            cand = os.path.join(base, os.path.basename(texture_path))
        else:
            cand = os.path.join("assets", "texturas", "Cancha.png")

        self.texture: Optional[pygame.Surface] = None
        self._scaled_texture: Optional[pygame.Surface] = None
        self._scaled_size: Optional[Tuple[int, int]] = None

        try:
            if _load_texture:
                # loader unificado (convert() ya se hace all√≠)
                self.texture = _load_texture(cand)
            else:
                self.texture = pygame.image.load(cand).convert_alpha()
        except Exception as e:
            print(f"[Field] No se pudo cargar la textura de la cancha '{cand}': {e}")
            self.texture = None

    # ---------- L√≠mites reales del court y red ----------
    def get_court_rect(self, screen: pygame.Surface) -> pygame.Rect:
        """
        Devuelve el √°rea jugable del court en coordenadas de pantalla.
        Si hay textura, usa su tama√±o escalado (cacheado) y centrado; si no, fallback s√≥lido.
        """
        if self._last_court_rect is not None:
            return self._last_court_rect.copy()

        W, H = screen.get_width(), screen.get_height()

        if self.texture:
            # Si ya tenemos textura, calculamos su rect destino seg√∫n scale_factor
            tw, th = self.texture.get_size()
            new_w = int(tw * self.scale_factor)
            new_h = int(th * self.scale_factor)
            rect = pygame.Rect(0, 0, new_w, new_h)
            rect.center = (W // 2, H // 2)
            return rect
        else:
            # Fallback si no hay textura
            court_w = int(W * 0.70)
            court_h = int(H * 0.78)
            court_x = (W - court_w) // 2
            court_y = (H - court_h) // 2 + int(H * 0.04)  # leve correcci√≥n visual
            return pygame.Rect(court_x, court_y, court_w, court_h)

    def get_net_rect(self, screen: pygame.Surface) -> pygame.Rect:
        """
        Rect que representa la red (vertical y centrado). Debe coincidir con lo que se dibuja.
        """
        court = self.get_court_rect(screen)
        net_w = max(4, int(court.width * 0.008))
        net_h = court.height
        net_x = court.centerx - net_w // 2
        net_y = court.y
        return pygame.Rect(net_x, net_y, net_w, net_h)
        
    def get_bounds(self) -> Tuple[float, float, float, float]:
        """Devuelve los l√≠mites del campo en unidades del mundo (coherente con la escala)"""
        # factor de escala: del Field l√≥gico a mundo ‚Äúreal‚Äù
        scale_x = 800 / self.width
        scale_y = 600 / self.height
        return 0, self.width * scale_x, 0, self.height * scale_y
    
    def draw_debug_bounds(self, surface: pygame.Surface) -> None:
        """Overlay de depuraci√≥n para ver court, red y cinta."""
        court = self.get_court_rect(surface)
        #net = self.get_net_rect(surface)
        pygame.draw.rect(surface, (30, 200, 255), court, width=2)  # contorno court
        pygame.draw.rect(surface, (255, 0, 0), (0, 0, self.width, self.height), 2)
        #pygame.draw.rect(surface, (255, 80, 80), net, width=2)     # red

    def get_target_zone(self, side, zone="center"):
        """
        Devuelve una coordenada (x, y) dentro del campo, en UNIDADES del Field (no p√≠xeles).
        side: 'top' o 'bottom'
        zone: 'left', 'center' o 'right'
        """

        mid_x = self.width / 2
        mid_y = self.height / 2

        # Dividimos el ancho del campo en 3 zonas
        left_range   = (0, mid_x - mid_x / 3)
        center_range = (mid_x - mid_x / 3, mid_x + mid_x / 3)
        right_range  = (mid_x + mid_x / 3, self.width)

        # Elegimos X seg√∫n zona
        if zone == "left":
            rx = random.uniform(*left_range)
        elif zone == "right":
            rx = random.uniform(*right_range)
        else:
            rx = random.uniform(*center_range)

        # Elegimos Y seg√∫n el lado opuesto del jugador
        if side == "top":
            ry = random.uniform(0.5, mid_y - 0.5)
        else:
            ry = random.uniform(mid_y + 0.5, self.height - 0.5)

        return rx, ry

    # ---------- Dibujo ----------
    def draw(self, screen: pygame.Surface) -> None:
        """
        Dibuja la cancha con textura centrada y la red en el centro.
        Adem√°s, cachea el rect del court para que Ball lo pueda usar en este frame.
        """
        # Fondo fuera de la cancha
        screen.fill((60, 160, 60))  # verde

        W, H = screen.get_width(), screen.get_height()

        # --- Fondo / textura ---
        if self.texture:
            tw, th = self.texture.get_size()
            target_size = (int(tw * self.scale_factor), int(th * self.scale_factor))

            # Cache: si no hay escalado previo o cambi√≥ el tama√±o objetivo, recalcular
            if self._scaled_texture is None or self._scaled_size != target_size:
                try:
                    self._scaled_texture = pygame.transform.smoothscale(self.texture, target_size)
                except Exception:
                    # Fallback si smoothscale no est√° disponible
                    self._scaled_texture = pygame.transform.scale(self.texture, target_size)
                self._scaled_size = target_size

            rect = self._scaled_texture.get_rect(center=(W // 2, H // 2))
            screen.blit(self._scaled_texture, rect)

            # Cacheamos el rect como "court real"
            self._last_court_rect = rect.copy()
        else:
            # Fallback: relleno s√≥lido si no hay textura
            screen.fill((0, 180, 0))
            self._last_court_rect = self.get_court_rect(screen)

        # --- Zonas isom√©tricas (dibujo original) ---
        # === DEBUG VISUAL DE ZONAS ===
        debug = False  # üîß activar/desactivar r√°pidamente

        if debug:
            color_map = {
                "deep_back_left": (128, 0, 0),      # rojo oscuro
                "back_left": (255, 0, 0),           # rojo
                "deep_front_left": (0, 128, 0),     # verde oscuro
                "front_left": (0, 255, 0),          # verde
                "deep_front_right": (0, 0, 128),    # azul oscuro
                "front_right": (0, 0, 255),         # azul
                "deep_back_right": (128, 128, 0),   # amarillo oscuro
                "back_right": (255, 255, 0),        # amarillo
                "center_back": (0, 0, 0),
                "center_front": (250, 250, 250),
            }
            for name, (x, y, w, h) in self.zones.items():
                # Calcular esquinas del rect√°ngulo en coordenadas del mundo
                corners = [
                    (x, y),
                    (x + w, y),
                    (x + w, y + h),
                    (x, y + h)
                ]

                # Convertir cada punto a coordenadas isom√©tricas
                iso_points = []
                for wx, wy in corners:
                    iso_x, iso_y = world_to_iso(wx - self.width / 2, wy - self.height / 2)
                    iso_x += screen.get_width() // 2
                    iso_y += screen.get_height() // 3
                    iso_points.append((iso_x, iso_y))

                # Dibujar el contorno isom√©trico
                pygame.draw.polygon(screen, color_map[name], iso_points, 2)

                # Etiqueta de zona
                font = pygame.font.SysFont("arial", 16)
                label = font.render(name, True, color_map[name])
                lx = sum(p[0] for p in iso_points) / 4
                ly = sum(p[1] for p in iso_points) / 4
                screen.blit(label, (lx - label.get_width() // 2, ly - label.get_height() // 2))

        """for name, (x, y, w, h) in self.zones.items():
            corners = [
                to_pixels(*world_to_screen(x, y),       SCALE, self.offset_x, self.offset_y),
                to_pixels(*world_to_screen(x + w, y),   SCALE, self.offset_x, self.offset_y),
                to_pixels(*world_to_screen(x + w, y+h), SCALE, self.offset_x, self.offset_y),
                to_pixels(*world_to_screen(x, y + h),   SCALE, self.offset_x, self.offset_y),
            ]

            # Color por tipo de zona
            color = {
                "back_left":  (0, 255, 0),
                "front_left": (0, 200, 255),
                "net_zone":   (255, 255, 0),
                "front_right": (255, 100, 0),
                "back_right": (255, 0, 0),
            }.get(name, (255, 255, 255))

            pygame.draw.polygon(screen, color, corners, 2)"""

        #self.net.update()
        #self.net.draw_debug(screen, SCALE, self.offset_x, self.offset_y)
        self.net.update_net(self._last_court_rect)
        self.net.draw(screen)


    def get_net_world_line(self):
        """
        Devuelve la l√≠nea de la red en coordenadas del mundo (x, y).
        """
        return (0, self.net_y), (self.width, self.net_y)

    def get_net_iso_line(self):
        """
        Devuelve la l√≠nea de la red en coordenadas de pantalla isom√©tricas (p√≠xeles).
        """
        (x1, y1), (x2, y2) = self.get_net_world_line()
        iso1 = world_to_screen(x1, y1)
        iso2 = world_to_screen(x2, y2)
        p1 = to_pixels(*iso1, SCALE, self.offset_x, self.offset_y)
        p2 = to_pixels(*iso2, SCALE, self.offset_x, self.offset_y)
        return p1, p2

    def ball_hits_net(self, ball_pos_screen: Tuple[float, float], ball_radius: float = 5.0) -> bool:
        """
        Determina si la pelota cruza la red isom√©trica.
        (Se mantiene por compatibilidad con l√≥gica antigua de pruebas; la colisi√≥n principal
         ahora la hacemos contra get_net_rect / get_net_tape_rect en Ball.update()).
        """
        (x1, y1), (x2, y2) = self.get_net_iso_line()
        bx, by = ball_pos_screen

        # Distancia punto-l√≠nea en 2D
        num = abs((y2 - y1) * bx - (x2 - x1) * by + x2*y1 - y2*x1)
        den = ((y2 - y1)**2 + (x2 - x1)**2)**0.5
        dist = num / max(1e-6, den)

        # Si la pelota est√° a menos de cierto margen (radio) => colisi√≥n
        return dist <= ball_radius
    

    def draw_debug_full(self, surface: pygame.Surface, ball=None, show_target=True):
        """
        Dibuja overlay de depuraci√≥n completo:
        - Cancha (contorno)
        - Red
        - L√≠mites de la cancha
        - Pelota y objetivo (si se pasa)
        """
        # --- Contorno de la cancha ---
        court = self.get_court_rect(surface)
        pygame.draw.rect(surface, (30, 200, 255), court, width=2)  # azul

        # --- L√≠mites reales de la cancha (en world coords) ---
        left, top = 0, 0
        right, bottom = self.width, self.height
        corners = [
            world_to_iso(left, top),
            world_to_iso(right, top),
            world_to_iso(right, bottom),
            world_to_iso(left, bottom),
        ]
        corners_px = [(x + ANCHO // 2, y + ALTO // 3) for x, y in corners]
        pygame.draw.polygon(surface, (255, 255, 0), corners_px, width=2)  # amarillo

        # --- Red ---
        self.net.draw_debug(surface)

        # --- Pelota y objetivo ---
        if ball:
            # Pelota
            px, py = ball.screen_x, ball.screen_y
            pygame.draw.circle(surface, (255, 255, 0), (int(px), int(py)), ball.radio)

            # Objetivo
            if show_target and hasattr(ball, "_target_pos"):
                tx, ty = ball._target_pos
                pygame.draw.circle(surface, (0, 255, 0), (int(tx), int(ty)), 5)
                pygame.draw.line(surface, (0, 255, 0), (px, py), (tx, ty), 1)

--- FIN DE ARCHIVO: engine/field.py ---

--- INICIO DE ARCHIVO: engine/game_object.py ---
import os
import json
import collections
from typing import Dict, List, Tuple, Optional

import pygame

# Intentamos usar el helper centralizado; si no est√° disponible,
# caemos a pygame.image.load convert_alpha() como hasta ahora.
try:
    from engine.assets.image_loader import load_image as _load_image
except Exception:
    _load_image = None

# Animator (opcional). Si no existe, seguimos funcionando sin animaci√≥n por tiempo.
try:
    from engine.animation.animator import Animator
except Exception:
    Animator = None  # type: ignore

FrameRect = Tuple[int, int, int, int]  # x, y, w, h


class GameObject:
    def __init__(self, x: float, y: float, json_path: str):
        self.x = x
        self.y = y

        self.sprite_sheet: Optional[pygame.Surface] = None
        self.animations: Dict[str, List[FrameRect]] = {}
        self.current_animation: str = 'idle'
        self.frame_index: int = 0
        self.rect: Optional[pygame.Rect] = None

        # Opcionales de presentaci√≥n
        self._shadow_enabled: bool = True  # sombra el√≠ptica bajo el objeto
        self._shadow_alpha: int = 70       # 0..255

        # Animator por tiempo (si est√° disponible)
        self._animator: Optional["Animator"] = Animator(default_fps=10) if Animator else None

        self.load_from_json(json_path)

    # --------------------------------------------------------------------- #
    # CARGA
    # --------------------------------------------------------------------- #
    def load_from_json(self, json_path: str) -> None:
        """
        Carga la spritesheet y los datos de animaci√≥n desde un archivo JSON.
        Maneja la ruta relativa/absoluta de forma segura y usa el loader
        centralizado si est√° disponible.
        """
        try:
            base_dir = os.path.dirname(os.path.abspath(json_path))
            with open(json_path, 'r', encoding='utf-8') as f:
                data = json.load(f)

            # Ruta a spritesheet: soporta absoluta o relativa (respetando subcarpetas)
            spritesheet_path_cfg = data.get('spritesheet_path')
            if not spritesheet_path_cfg:
                raise ValueError("El JSON no contiene 'spritesheet_path'.")

            if os.path.isabs(spritesheet_path_cfg):
                # Si viniera absoluta, la normalizamos a basename dentro del JSON dir
                candidate = os.path.join(base_dir, os.path.basename(spritesheet_path_cfg))
            else:
                # Si es relativa, intentamos primero relativa real (con subcarpetas)
                candidate = os.path.normpath(os.path.join(base_dir, spritesheet_path_cfg))
                if not os.path.exists(candidate):
                    # Fallback a basename por portabilidad si no existe
                    candidate = os.path.join(base_dir, os.path.basename(spritesheet_path_cfg))

            if not os.path.exists(candidate):
                raise FileNotFoundError(f"Spritesheet no encontrada: {candidate}")

            # Cargar la imagen con helper (si est√°) o fallback a pygame
            if _load_image:
                self.sprite_sheet = _load_image(candidate)
            else:
                self.sprite_sheet = pygame.image.load(candidate).convert_alpha()

            # Animaciones: default dict de listas
            self.animations = collections.defaultdict(list)
            for anim_name, anim_list in (data.get('animations') or {}).items():
                if not isinstance(anim_list, list):
                    continue
                for sprite_data in anim_list:
                    x = int(sprite_data['x'])
                    y = int(sprite_data['y'])
                    w = int(sprite_data['width'])
                    h = int(sprite_data['height'])
                    # Guardamos las coordenadas de cada sprite como una tupla
                    self.animations[anim_name].append((x, y, w, h))

            if not self.animations:
                raise ValueError("No se encontraron animaciones v√°lidas en el JSON.")

            # Animaci√≥n inicial y rect de colisi√≥n
            self.current_animation = 'idle' if 'idle' in self.animations else list(self.animations.keys())[0]
            first_frames = self.animations[self.current_animation]
            if not first_frames:
                raise ValueError(f"La animaci√≥n inicial '{self.current_animation}' no tiene frames.")
            fx, fy, fw, fh = first_frames[0]
            self.rect = pygame.Rect(self.x, self.y, fw, fh)

        except FileNotFoundError as e:
            print(f"[GameObject] Error de archivo: {e}")
            self.sprite_sheet = None
            self.animations = {}
            self.rect = None
        except Exception as e:
            print(f"[GameObject] Error al cargar '{json_path}': {e}")
            self.sprite_sheet = None
            self.animations = {}
            self.rect = None

    # --------------------------------------------------------------------- #
    # UPDATE (animaci√≥n por tiempo)
    # --------------------------------------------------------------------- #
    def update(self) -> None:
        """
        Avanza la animaci√≥n seg√∫n el tiempo si hay Animator disponible.
        Si no hay Animator, no hace nada (el Player puede avanzar frames manualmente).
        """
        if not self._animator:
            return
        if not self.animations or self.current_animation not in self.animations:
            return

        if self._animator.update(self.current_animation):
            frames = self.animations[self.current_animation]
            if frames:
                self.frame_index = (self.frame_index + 1) % len(frames)

    # --------------------------------------------------------------------- #
    # RENDER
    # --------------------------------------------------------------------- #
    def draw(self, surface: pygame.Surface) -> None:
        """
        Dibuja el fotograma actual en la pantalla (con sombra opcional).
        """
        if not self.sprite_sheet or not self.animations or not self.rect:
            return

        # Asegurar animaci√≥n v√°lida
        if self.current_animation not in self.animations:
            # Fallback a alguna animaci√≥n disponible
            self.current_animation = next(iter(self.animations.keys()))

        frames = self.animations.get(self.current_animation, [])
        if not frames:
            return

        # Evitar IndexError si el frame_index qued√≥ fuera de rango
        self.frame_index %= len(frames)
        fx, fy, fw, fh = frames[self.frame_index]

        # Validar que el rect del frame est√© dentro de la spritesheet
        if not self._frame_in_bounds(fx, fy, fw, fh, self.sprite_sheet):
            # Si el JSON trae coords fuera de la hoja, evitamos ValueError
            # e intentamos dibujar el primer frame seguro.
            fx, fy, fw, fh = frames[0]
            if not self._frame_in_bounds(fx, fy, fw, fh, self.sprite_sheet):
                return  # nada que dibujar

        # ---------- Sombra (elipse) bajo el objeto ----------
        if self._shadow_enabled:
            shadow_w = int(self.rect.width * 0.6)
            shadow_h = max(4, int(self.rect.height * 0.18))
            if shadow_w > 4 and shadow_h > 2:
                shadow = pygame.Surface((shadow_w, shadow_h), pygame.SRCALPHA)
                pygame.draw.ellipse(shadow, (0, 0, 0, self._shadow_alpha), shadow.get_rect())
                sh_rect = shadow.get_rect(midtop=(self.rect.centerx, self.rect.bottom - shadow_h // 2))
                surface.blit(shadow, sh_rect)

        # ---------- Dibujar frame actual ----------
        frame_surf = self.sprite_sheet.subsurface(pygame.Rect(fx, fy, fw, fh))
        surface.blit(frame_surf, self.rect)

    # --------------------------------------------------------------------- #
    # HELPERS
    # --------------------------------------------------------------------- #
    @staticmethod
    def _frame_in_bounds(x: int, y: int, w: int, h: int, sheet: pygame.Surface) -> bool:
        sw, sh = sheet.get_width(), sheet.get_height()
        return (0 <= x < sw) and (0 <= y < sh) and (w > 0) and (h > 0) and (x + w <= sw) and (y + h <= sh)

--- FIN DE ARCHIVO: engine/game_object.py ---

--- INICIO DE ARCHIVO: engine/game.py ---
import os
import json
import pygame

from engine.player import Player
from engine.field import Field
from engine.utils.colors import AZUL_OSCURO, BLANCO
from engine.utils.screen import ANCHO, ALTO, world_to_screen
from engine.audio import AudioManager
from engine.ball import Ball

# Debug overlays (pique IN/OUT)
try:
    from engine.debug.overlays import DebugOverlays
except Exception:
    DebugOverlays = None  # type: ignore

# Overlay 3-2-1
try:
    from engine.ui.countdown import RestartCountdown
except Exception:
    RestartCountdown = None  # type: ignore

# IA simple para P2 (modo 1P)
try:
    from engine.ai.simple_ai import SimpleTennisAI
except Exception:
    SimpleTennisAI = None  # type: ignore

# Puntuaci√≥n
try:
    from engine.rules.score import ScoreManager
except Exception:
    ScoreManager = None  # type: ignore


class Game:
    def __init__(self):
        # Ventana
        self.PANTALLA = pygame.display.set_mode((ANCHO, ALTO))
        pygame.display.set_caption('Tennis Isom√©trico en construcci√≥n...')

        # Mundo
        self.field = Field(6, 10)
        self.jugador1 = Player(520, 350,  field=self.field, jugador2=False, game=self)# >x = M√°s a la derecha, >y = M√°s atr√°s
        self.jugador2 = Player(385, ALTO / 2 - 450, field=self.field, jugador2=True, game=self)

        # Reloj
        self.reloj = pygame.time.Clock()

        # --- AUDIO ---
        self.audio = AudioManager()
        self._load_audio_assets()

        # Config persistente de audio
        self.config_path = os.path.join("assets", "audio_config.json")
        self._load_audio_config()

        # Flags de desarrollo
        self.debug_audio = os.getenv("VJ2D_DEBUG_AUDIO", "1") == "1"
        self.use_crowd_ambience = False

        # M√∫sica por estado ‚Üí MEN√ö (respetando mute de grupo)
        self._set_music_state("menu")

        # ---- MODO / ESTADOS ----
        self.modo = os.getenv("VJ2D_MODO", "1P")
        self.estado_juego = 'menu'  # 'menu'|'opciones'|'jugando'|'pausa'|'victoria'|'gameover'

        # Men√∫ simple
        self.menu_items = ["Comenzar", "Opciones", "Salir"]
        self.menu_index = 0

        # Fuentes
        self.font_title = pygame.font.Font(None, 64)
        self.font_item  = pygame.font.Font(None, 44)
        self.font_small = pygame.font.Font(None, 32)
        self.font_hud   = pygame.font.Font(None, 38)

        # Score
        self.score = ScoreManager() if ScoreManager else None

        # Pelotas
        self.balls = pygame.sprite.Group()
        self._ball_main = None  # referencia a la pelota "principal"
        self.current_server = "P1"
        # IA / control seg√∫n modo
        self.ai_p2 = None
        if self.modo == "1P" and SimpleTennisAI is not None:
            self.jugador2.is_human = False
            self.jugador2.home_x = getattr(self.jugador2, "world_x", getattr(self.jugador2, "x", 0))
            self.jugador2.home_y = getattr(self.jugador2, "world_y", getattr(self.jugador2, "y", 0))
            self.ai_p2 = SimpleTennisAI(self.jugador2, None, side="top")  # type: ignore
        else:
            self.jugador2.is_human = True

        # Debug overlay (F1 = bounds, F3 = bounces)
        self._debug_bounds = False
        self.debug_overlays = DebugOverlays() if DebugOverlays else None
        self.show_bounce_debug = True

        # Mute m√∫sica (legacy, mantenido para UI de opciones)
        self._music_muted = False
        self._music_prev_vol = self.audio.group_vol.get("music", 0.4)

        # Opciones de Audio
        self._opts_names  = ["M√∫sica", "SFX", "UI"]
        self._opts_groups = ["music",  "sfx", "ui"]
        self._opts_index  = 0
        self._opts_values = [
            self.modo,
            self.audio.group_vol["music"],
            self.audio.group_vol["sfx"],
            self.audio.group_vol["ui"],
        ]

        # √öltimo que peg√≥
        self.last_hitter = None  # "P1"/"P2"/None

        # --- Cuenta regresiva de reinicio (punto 4) ---
        self._restart_cd = RestartCountdown(self._reiniciar_partida) if RestartCountdown else None
        self._restart_block_input = False  # si True, no procesamos entradas de juego durante el 3-2-1

    # ---------------------------
    # Config de juego (modo 1P/2P)
    # ---------------------------
    def _load_game_config(self):
        try:
            if os.path.exists(self.game_config_path):
                with open(self.game_config_path, "r", encoding="utf-8") as f:
                    cfg = json.load(f)
                m = str(cfg.get("modo", "1P")).upper()
                if m in ("1P", "2P"):
                    self.modo = m
        except Exception as e:
            print(f"[GameCfg] No se pudo leer game_config.json: {e}")

    def _save_game_config(self):
        try:
            os.makedirs(os.path.dirname(self.game_config_path), exist_ok=True)
            with open(self.game_config_path, "w", encoding="utf-8") as f:
                json.dump({"modo": self.modo}, f, indent=2)
        except Exception as e:
            print(f"[GameCfg] No se pudo guardar game_config.json: {e}")

    def _apply_mode(self):
        """Aplica el modo actual (1P ‚Üí IA en P2; 2P ‚Üí ambos humanos)."""
        if self.modo == "1P" and SimpleTennisAI is not None:
            self.jugador2.is_human = False
            self.jugador2.home_x = getattr(self.jugador2, "world_x", getattr(self.jugador2, "x", 0))
            self.jugador2.home_y = getattr(self.jugador2, "world_y", getattr(self.jugador2, "y", 0))
            self.ai_p2 = SimpleTennisAI(self.jugador2, self._ball_main, side="top")  # type: ignore
        else:
            self.jugador2.is_human = True
            self.ai_p2 = None

    def _set_mode(self, new_mode: str):
        new_mode = (new_mode or "").upper()
        if new_mode not in ("1P", "2P"):
            return
        if new_mode == self.modo:
            return
        self.modo = new_mode
        self._apply_mode()
        self._save_game_config()
        if hasattr(self, "audio"):
            self.audio.play_sound("ui_select")

    # ---------------------------
    # Carga de sonidos
    # ---------------------------
    def _load_audio_assets(self):
        ap = os.path.join("assets", "audio")
        def p(n): return os.path.join(ap, n)

        # UI
        self.audio.load_sound("ui_move",    p("ui_move.wav"),    0.6, group="ui",  cooldown_ms=90)
        self.audio.load_sound("ui_select",  p("ui_select.wav"),  0.8, group="ui",  cooldown_ms=120)
        self.audio.load_sound("ui_back",    p("ui_back.wav"),    0.6, group="ui",  cooldown_ms=120)
        if os.path.exists(p("ui_whoosh.wav")):
            self.audio.load_sound("ui_whoosh", p("ui_whoosh.wav"), 0.7, group="ui", cooldown_ms=300)

        # Tenis base
        self.audio.load_sound("serve",         p("serve.wav"),        0.9, group="sfx", cooldown_ms=150)
        if os.path.exists(p("serve2.wav")):
            self.audio.load_sound("serve2",    p("serve2.wav"),       0.9, group="sfx", cooldown_ms=150)
            self.audio.register_variants("serve", "serve2")

        self.audio.load_sound("hit_racket",    p("hit_racket.wav"),   0.8, group="sfx", cooldown_ms=40)
        self.audio.load_sound("bounce_court",  p("bounce_court.wav"), 0.7, group="sfx", cooldown_ms=60)

        # Compat viejo
        if os.path.exists(p("net_touch.wav")):
            self.audio.load_sound("net_touch", p("net_touch.wav"), 0.7, group="sfx", cooldown_ms=120)

        self.audio.load_sound("out_whistle",   p("out_whistle.wav"),  0.7, group="sfx", cooldown_ms=300)
        self.audio.load_sound("score_jingle",  p("score_jingle.wav"), 0.8, group="sfx", cooldown_ms=400)

        # Variantes opcionales
        variants = []
        for i in (2, 3):
            fn = f"hit_racket{i}.wav"
            if os.path.exists(p(fn)):
                self.audio.load_sound(f"hit_racket{i}", p(fn), 0.8, group="sfx", cooldown_ms=40)
                variants.append(f"hit_racket{i}")
        if variants:
            self.audio.register_variants("hit_racket", *variants)

        # P√∫blico (opcionales)
        if os.path.exists(p("crowd_ooh.wav")):
            self.audio.load_sound("crowd_ooh", p("crowd_ooh.wav"), 0.75, group="sfx", cooldown_ms=300)
        if os.path.exists(p("crowd_ahh.wav")):
            self.audio.load_sound("crowd_ahh", p("crowd_ahh.wav"), 0.75, group="sfx", cooldown_ms=300)

        # Jingles fin (opcionales)
        if os.path.exists(p("win_jingle.wav")):
            self.audio.load_sound("win_jingle",  p("win_jingle.wav"),  0.9, group="sfx", cooldown_ms=1500)
        if os.path.exists(p("lose_jingle.wav")):
            self.audio.load_sound("lose_jingle", p("lose_jingle.wav"), 0.9, group="sfx", cooldown_ms=1500)
        if os.path.exists(p("sting_match.wav")):
            self.audio.load_sound("sting_match", p("sting_match.wav"), 0.85, group="sfx", cooldown_ms=800)

        # NUEVO: sonidos de red (cinta/cuerpo)
        if hasattr(self.audio, "load_net_sfx"):
            self.audio.load_net_sfx()

    # ---------------------------
    # Persistencia de audio
    # ---------------------------
    def _load_audio_config(self):
        try:
            with open(self.config_path, "r", encoding="utf-8") as f:
                cfg = json.load(f)
            for g in ("music", "sfx", "ui"):
                if g in cfg and isinstance(cfg[g], (int, float)):
                    self.audio.set_group_volume(g, float(cfg[g]))
        except Exception:
            pass

    def _save_audio_config(self):
        cfg = {
            "music": self.audio.group_vol["music"],
            "sfx":   self.audio.group_vol["sfx"],
            "ui":    self.audio.group_vol["ui"],
        }
        try:
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            with open(self.config_path, "w", encoding="utf-8") as f:
                json.dump(cfg, f, indent=2)
        except Exception as e:
            print(f"[Audio] No se pudo guardar config: {e}")

    # ---------------------------
    # M√∫sica por estado (respeta mute)
    # ---------------------------
    def _set_music_state(self, state: str):
        def ap(*parts):
            return os.path.join("assets", "audio", *parts)

        # Importante: NO forzar volume en play_music; dejar que use el del grupo
        # as√≠ si el usuario mute√≥ m√∫sica, se respeta.
        if state == "menu":
            self.audio.fadeout_music(200)
            path = ap("menu_music.wav")
            if os.path.exists(path):
                self.audio.load_music(path)
                self.audio.play_music(loops=-1, volume=None)
            return

        if state == "ingame":
            self.audio.fadeout_music(200)
            music_path = None
            if self.use_crowd_ambience and os.path.exists(ap("crowd_loop.wav")):
                music_path = ap("crowd_loop.wav")
            elif os.path.exists(ap("ingame_music.wav")):
                music_path = ap("ingame_music.wav")
            if music_path:
                self.audio.load_music(music_path)
                self.audio.play_music(loops=-1, volume=None)

    # ---------------------------
    # Bucle principal
    # ---------------------------
    def game_loop(self):
        ejecutando = True
        while ejecutando:
            dt = self.reloj.tick(15)

            # Overlays (lifetime)
            if self.debug_overlays:
                self.debug_overlays.update(dt)
            if self._restart_cd and self._restart_cd.active:
                self._restart_cd.update(dt)

            # INPUT
            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    ejecutando = False

                elif evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_F1:
                        self._debug_bounds = not self._debug_bounds
                        if hasattr(self.field, "debug"):
                            self.field.debug = self._debug_bounds

                    if evento.key == pygame.K_F3 and self.debug_overlays:
                        self.show_bounce_debug = not self.show_bounce_debug
                    # üéæ Saque jugador 1 y jugador 2
                    # --- Jugador 1 ---
                    if evento.key == pygame.K_SPACE:
                        # Asegurarse de que haya una pelota principal
                        ball = self._ball_main
                        if ball is not None:
                            # Si la pelota est√° lista para sacar ‚Üí lanzar hacia arriba
                            if getattr(ball, "serve_stage", "ready") == "ready":
                                # Posici√≥n inicial del jugador 1 (desde world_x, world_y)
                                start_x, start_y = world_to_screen(self.jugador1.world_x, self.jugador1.world_y)
                                ball.start_toss("P1", start_x - 20, start_y - 60)
                                self.jugador1.iniciar_saque()  # animaci√≥n del lanzamiento
                            # Si la pelota ya fue lanzada ‚Üí intentar golpear
                            elif getattr(ball, "serve_stage", None) in ("toss", "falling"):
                                if self.jugador1:
                                    self.jugador1.realizar_saque()
                                    ball.hit_by_player((self.jugador1.world_x, self.jugador1.world_y), zone=self.jugador1.pending_direction, is_player2=self.jugador1.is_player2)
                                else:
                                    self.jugador2.realizar_saque()
                                    ball.hit_by_player((self.jugador2.world_x, self.jugador2.world_y), zone=self.jugador2.pending_direction, is_player2=self.jugador2.is_player2)
                        else:
                            print("[WARN] No hay pelota principal activa para el saque.")

                    # --- Jugador 2 ---
                    if evento.key == pygame.K_f:
                        # Asegurarse de que haya una pelota principal
                        ball = self._ball_main
                        if ball is not None:
                            # Si la pelota est√° lista para sacar ‚Üí lanzar hacia arriba
                            if getattr(ball, "serve_stage", "ready") == "ready":
                                start_x = self.jugador2.world_x
                                start_y = self.jugador2.world_y
                                ball.start_toss("P2", start_x, start_y)
                                self.jugador2.iniciar_saque()  # animaci√≥n del lanzamiento
                            # Si la pelota ya fue lanzada ‚Üí intentar golpear
                            elif getattr(ball, "serve_stage", None) in ("toss", "falling"):
                                self.jugador2.golpear_saque()
                                ball.hit_by_player()
                        else:
                            print("[WARN] No hay pelota principal activa para el saque.")

                    # Mezcla r√°pida
                    if evento.key == pygame.K_1:
                        v = max(0.0, self.audio.group_vol["music"] - 0.05)
                        self.audio.set_group_volume("music", v)
                        self._music_prev_vol = v if not self._music_muted else self._music_prev_vol
                    if evento.key == pygame.K_2:
                        v = min(1.0, self.audio.group_vol["music"] + 0.05)
                        self.audio.set_group_volume("music", v)
                        self._music_prev_vol = v if not self._music_muted else self._music_prev_vol
                    if evento.key == pygame.K_3:
                        v = max(0.0, self.audio.group_vol["sfx"] - 0.05)
                        self.audio.set_group_volume("sfx", v)
                    if evento.key == pygame.K_4:
                        v = min(1.0, self.audio.group_vol["sfx"] + 0.05)
                        self.audio.set_group_volume("sfx", v)

                    # Mute global (respeta al reiniciar)
                    if evento.key == pygame.K_m:
                        self.audio.toggle_mute_all()

                    # ---- ESTADOS ----
                    if self.estado_juego == 'menu':
                        # Atajos de modo en MEN√ö: 1 ‚Üí 1P, 2 ‚Üí 2P
                        if evento.key == pygame.K_1:
                            self._set_mode("1P")
                        elif evento.key == pygame.K_2:
                            self._set_mode("2P")
                        elif evento.key in (pygame.K_UP, pygame.K_w):
                            self.menu_index = (self.menu_index - 1) % len(self.menu_items)
                            self.audio.play_sound("ui_move")
                        elif evento.key in (pygame.K_DOWN, pygame.K_s):
                            self.menu_index = (self.menu_index + 1) % len(self.menu_items)
                            self.audio.play_sound("ui_move")
                        elif evento.key in (pygame.K_RETURN, pygame.K_SPACE):
                            self.audio.play_sound("ui_select")
                            self._menu_select()
                        elif evento.key == pygame.K_ESCAPE:
                            self.audio.play_sound("ui_back")
                            ejecutando = False

                    elif self.estado_juego == 'opciones':
                        handled = self._handle_options_input(evento.key)
                        if not handled and evento.key == pygame.K_ESCAPE:
                            self.estado_juego = 'menu'

                    elif self.estado_juego == 'jugando':
                        # No aceptar entradas de gameplay durante el 3-2-1
                        if self._restart_block_input:
                            # pero s√≠ permitir Esc para pausar/salir
                            if evento.key == pygame.K_ESCAPE:
                                if "ui_whoosh" in self.audio.sounds:
                                    self.audio.play_sound("ui_whoosh")
                                self.audio.play_sound("ui_back")
                                self.estado_juego = 'pausa'
                                self.audio.duck_music(0.08)
                            continue

                        if evento.key == pygame.K_ESCAPE:
                            if "ui_whoosh" in self.audio.sounds:
                                self.audio.play_sound("ui_whoosh")
                            self.audio.play_sound("ui_back")
                            self.estado_juego = 'pausa'
                            self.audio.duck_music(0.08)

                        # Debug SFX y AUTOGANAR ‚Üí ahora ‚Äúreinicio 3-2-1‚Äù
                        if self.debug_audio:
                            if evento.key == pygame.K_v:
                                self.audio.play_sound("serve")
                            if evento.key == pygame.K_h:
                                for b in self.balls:
                                    b.on_racket_hit()
                                    break
                            if evento.key == pygame.K_b:
                                self.audio.play_sound("bounce_court")
                            if evento.key == pygame.K_n:
                                if "net_tape" in self.audio.sounds:
                                    self.audio.play_sound("net_tape")
                                if "net_body" in self.audio.sounds:
                                    self.audio.play_sound("net_body")
                                elif "net_touch" in self.audio.sounds:
                                    self.audio.play_sound("net_touch")
                                if "crowd_ooh" in self.audio.sounds:
                                    self.audio.play_sound("crowd_ooh")
                            if evento.key == pygame.K_o:
                                for b in self.balls:
                                    b.on_out()
                                    break
                            if evento.key == pygame.K_p:
                                for b in self.balls:
                                    b.on_point_scored()
                                    break
                            if evento.key == pygame.K_c and "crowd_ooh" in self.audio.sounds:
                                self.audio.play_sound("crowd_ooh")
                            if evento.key == pygame.K_f and "crowd_ahh" in self.audio.sounds:
                                self.audio.play_sound("crowd_ahh")
                            if evento.key == pygame.K_k and "sting_match" in self.audio.sounds:
                                self.audio.duck_music(0.10)
                                self.audio.play_sound("sting_match")
                                self.audio.unduck_music()

                            # <<<< Punto 4: antes hac√≠a _enter_victoria(); ahora 3-2-1 sin cartel >>>>
                            if evento.key == pygame.K_g:
                                self._start_debug_restart_countdown()

                    elif self.estado_juego == 'pausa':
                        if evento.key in (pygame.K_ESCAPE, pygame.K_p):
                            if "ui_whoosh" in self.audio.sounds:
                                self.audio.play_sound("ui_whoosh")
                            self.audio.play_sound("ui_back")
                            self.estado_juego = 'jugando'
                            self.audio.unduck_music()

                    elif self.estado_juego in ('victoria', 'gameover'):
                        if evento.key in (pygame.K_RETURN, pygame.K_KP_ENTER):
                            self._reiniciar_partida()
                        elif evento.key == pygame.K_ESCAPE:
                            self._volver_al_menu()

            # L√ìGICA
            if self.estado_juego == 'jugando':
                teclas = pygame.key.get_pressed()

                # Bloqueo de entradas/movimientos durante el 3-2-1
                if not self._restart_block_input:
                    # P1 (humano)
                    self.jugador1.mover(teclas)

                    # P2: IA en 1P, humano en 2P
                    if self.modo == "1P" and self.ai_p2 is not None and self._ball_main is not None:
                        # asegurar referencia a la pelota por si cambi√≥ en el rally
                        if getattr(self.ai_p2, "ball", None) is not self._ball_main:
                            self.ai_p2.ball = self._ball_main  # type: ignore
                        # obtener las teclas simuladas desde la IA
                        simulated_keys = self.ai_p2.get_simulated_keys()

                        # mover jugador 2 usando las teclas simuladas
                        self.jugador2.mover(simulated_keys)
                    else:
                        self.jugador2.mover(teclas)

                # Actualizaci√≥n de animaciones/estado visual
                self.jugador1.update()
                self.jugador2.update()

                # Pelota (no se mueve durante el 3-2-1)
                if not self._restart_block_input:
                    self.balls.update()

                # Colisiones jugador-pelota (no durante el 3-2-1)
                if not self._restart_block_input:
                    for ball in self.balls:
                        if self.jugador1.check_ball_collision(ball):
                            self.last_hitter = "P1"
                        if self.jugador2.check_ball_collision(ball):
                            self.last_hitter = "P2"


            # RENDER
            self.PANTALLA.fill(AZUL_OSCURO)

            if self.estado_juego == 'menu':
                self._draw_menu()
            elif self.estado_juego == 'opciones':
                self._draw_options()
            elif self.estado_juego == 'jugando':
                self._render_ingame()
            elif self.estado_juego == 'pausa':
                self._render_ingame()
                self._draw_center_text("PAUSA (Esc/P para volver)")
            elif self.estado_juego == 'victoria':
                self._render_victoria()
            elif self.estado_juego == 'gameover':
                self._render_gameover()

            # Overlays
            if self.debug_overlays and self.show_bounce_debug:
                self.debug_overlays.draw(self.PANTALLA)
            if self._restart_cd and self._restart_cd.active:
                self._restart_cd.draw(self.PANTALLA, "Reiniciando partida")

            pygame.display.flip()

        # Guardar mezcla al salir
        self._save_audio_config()
        pygame.quit()

    # ---------------------------
    # MEN√ö
    # ---------------------------
    def _menu_select(self):
        item = self.menu_items[self.menu_index]
        if item == "Comenzar":
            self._set_music_state("ingame")
            self.estado_juego = 'jugando'
            self._start_new_rally()
        elif item == "Opciones":
            self._enter_options()
        elif item == "Salir":
            pygame.event.post(pygame.event.Event(pygame.QUIT))

    def _draw_menu(self):
        title = self.font_title.render("Tennis Isom√©trico", True, BLANCO)
        self.PANTALLA.blit(title, title.get_rect(center=(ANCHO // 2, 140)))
        for i, txt in enumerate(self.menu_items):
            sel = (i == self.menu_index)
            label = f"> {txt} <" if sel else f"  {txt}  "
            surf = self.font_item.render(label, True, BLANCO)
            self.PANTALLA.blit(surf, surf.get_rect(center=(ANCHO // 2, 260 + i * 60)))
        modo_txt = f"Modo: {self.modo}  (env VJ2D_MODO=1P/2P)"
        hint = self.font_small.render(modo_txt, True, BLANCO)
        self.PANTALLA.blit(hint, hint.get_rect(center=(ANCHO // 2, 260 + len(self.menu_items)*60 + 30)))

    def _draw_center_text(self, msg):
        surf = self.font_item.render(msg, True, BLANCO)
        self.PANTALLA.blit(surf, surf.get_rect(center=(ANCHO // 2, ALTO // 2)))

    # ---------------------------
    # Opciones (ahora incluye Modo)
    # ---------------------------
    def _enter_options(self):
        if "ui_whoosh" in self.audio.sounds:
            self.audio.play_sound("ui_whoosh")
        self.audio.play_sound("ui_select")
        self.estado_juego = 'opciones'
        self._opts_values = [
            self.modo,                              # √≠ndice 0: "1P"/"2P"
            self.audio.group_vol["music"],          # 1
            self.audio.group_vol["sfx"],            # 2
            self.audio.group_vol["ui"],             # 3
        ]
        self._opts_index = 0

    def _handle_options_input(self, key) -> bool:
        if key in (pygame.K_ESCAPE,):
            self.audio.play_sound("ui_back")
            if "ui_whoosh" in self.audio.sounds:
                self.audio.play_sound("ui_whoosh")
            self.estado_juego = 'menu'
            return True

        if key in (pygame.K_RETURN, pygame.K_SPACE):
            # Aplicar vol√∫menes
            for i, g in enumerate(self._opts_groups):
                if g:  # s√≥lo grupos de audio (√≠ndice 0 es None)
                    self.audio.set_group_volume(g, self._opts_values[i])
            self._save_audio_config()
            # Guardar modo
            self._save_game_config()
            self.audio.play_sound("ui_select")
            if "ui_whoosh" in self.audio.sounds:
                self.audio.play_sound("ui_whoosh")
            self.estado_juego = 'menu'
            return True

        if key in (pygame.K_UP, pygame.K_w):
            self._opts_index = (self._opts_index - 1) % len(self._opts_names)
            self.audio.play_sound("ui_move")
            return True
        if key in (pygame.K_DOWN, pygame.K_s):
            self._opts_index = (self._opts_index + 1) % len(self._opts_names)
            self.audio.play_sound("ui_move")
            return True

        idx = self._opts_index
        if idx == 0:
            # Toggle de "Modo de juego"
            if key in (pygame.K_LEFT, pygame.K_a, pygame.K_RIGHT, pygame.K_d):
                self._set_mode("2P" if self.modo == "1P" else "1P")
                self._opts_values[0] = self.modo
                return True
        else:
            # Sliders de audio
            if key in (pygame.K_LEFT, pygame.K_a):
                self._opts_values[idx] = max(0.0, round(self._opts_values[idx] - 0.05, 2))
                self.audio.set_group_volume(self._opts_groups[idx], self._opts_values[idx])
                return True
            if key in (pygame.K_RIGHT, pygame.K_d):
                self._opts_values[idx] = min(1.0, round(self._opts_values[idx] + 0.05, 2))
                self.audio.set_group_volume(self._opts_groups[idx], self._opts_values[idx])
                return True

        return False

    def _draw_options(self):
        title = self.font_title.render("Opciones", True, BLANCO)
        self.PANTALLA.blit(title, title.get_rect(center=(ANCHO // 2, 120)))
        y0 = 220
        for i, name in enumerate(self._opts_names):
            sel = (i == self._opts_index)
            label = f"> {name} <" if sel else f"  {name}  "
            if i == 0:
                line = f"{label} : {self.modo}  (‚Üê/‚Üí)"
            else:
                val = int(self._opts_values[i] * 100)
                line = f"{label} : {val}%"
            surf = self.font_item.render(line, True, BLANCO)
            self.PANTALLA.blit(surf, surf.get_rect(center=(ANCHO // 2, y0 + i * 60)))
        hint = "‚Üê/‚Üí ajustar, ‚Üë/‚Üì mover, Enter guardar, Esc cancelar"
        hs = self.font_small.render(hint, True, BLANCO)
        self.PANTALLA.blit(hs, hs.get_rect(center=(ANCHO // 2, y0 + 60 * len(self._opts_names) + 40)))

    # ---------------------------
    # Jingles / ESTADOS FINALES
    # ---------------------------
    def _enter_victoria(self):
        self.estado_juego = 'victoria'
        self.audio.fadeout_music(200)
        if "win_jingle" in self.audio.sounds:
            self.audio.play_sound("win_jingle")
        else:
            self._set_music_state("menu")

    def _enter_gameover(self):
        self.estado_juego = 'gameover'
        self.audio.fadeout_music(200)
        if "lose_jingle" in self.audio.sounds:
            self.audio.play_sound("lose_jingle")
        else:
            self._set_music_state("menu")

    # ---------------------------
    # RENDER helpers
    # ---------------------------
    def _render_ingame(self):
        self.field.draw(self.PANTALLA)

        if self._debug_bounds:
            self.field.draw_debug_bounds(self.PANTALLA)
            self.field.net.draw_debug(self.PANTALLA)

        for b in self.balls:
            b.draw(self.PANTALLA)

        self.jugador2.draw(self.PANTALLA)
        self.jugador1.draw(self.PANTALLA)

        if self._debug_bounds:
            self._draw_player_hitboxes(self.jugador1, self.PANTALLA)
            self._draw_player_hitboxes(self.jugador2, self.PANTALLA)

        if self.score:
            self.score.draw_hud(self.PANTALLA, self.font_hud)

    def _render_victoria(self):
        # Fondo tenue del ingame + cartel
        self._render_ingame()
        overlay = pygame.Surface((ANCHO, ALTO), pygame.SRCALPHA)
        overlay.fill((10, 40, 10, 180))
        self.PANTALLA.blit(overlay, (0, 0))
        t1 = self.font_title.render("¬°VICTORIA!", True, BLANCO)
        t2 = self.font_small.render("Enter: Reintentar   |   Esc: Volver al men√∫", True, BLANCO)
        self.PANTALLA.blit(t1, t1.get_rect(center=(ANCHO // 2, ALTO // 2 - 20)))
        self.PANTALLA.blit(t2, t2.get_rect(center=(ANCHO // 2, ALTO // 2 + 40)))

    def _render_gameover(self):
        self._render_ingame()
        overlay = pygame.Surface((ANCHO, ALTO), pygame.SRCALPHA)
        overlay.fill((40, 10, 10, 180))
        self.PANTALLA.blit(overlay, (0, 0))
        t1 = self.font_title.render("GAME OVER", True, BLANCO)
        t2 = self.font_small.render("Enter: Reintentar   |   Esc: Volver al men√∫", True, BLANCO)
        self.PANTALLA.blit(t1, t1.get_rect(center=(ANCHO // 2, ALTO // 2 - 20)))
        self.PANTALLA.blit(t2, t2.get_rect(center=(ANCHO // 2, ALTO // 2 + 40)))

    def set_starting_player(self, player: str):
        """Permite elegir el jugador que saca ('P1' o 'P2')."""
        p = (player or "").upper()
        if p in ("P1", "P2"):
            self.current_server = p
        else:
            # Fallback por si la entrada es inv√°lida
            print(f"[ERROR] Jugador inicial inv√°lido: {player}. Usando '{self.current_server}'.")

    # ---------------------------
    # Rally / PUNTUACI√ìN donde empieza la pelota
    # ---------------------------
    def _start_new_rally(self):
        cx, cy = self.jugador1.x, self.jugador1.y
        wx, wy = world_to_screen(cx, cy)
        self.balls.empty()
        ball = Ball(wx - 20, wy - 60, game=self, vx=0, vy=0)
        ball.z = 50
        ball.serve_stage = "ready"
        self.balls.add(ball)
        self._ball_main = ball
        ball.start_rally()
        ball.launch_toward_random_zone()
        self.last_hitter = None

        if self.ai_p2 is not None:
            self.ai_p2.ball = ball  # type: ignore

        if self.score and self.score.game_winner:
            self.score.reset_game()

    def point_for(self, who: str):
        if not self.score:
            self._start_new_rally()
            return

        self.score.point_for(who)

        gw = getattr(self.score, "game_winner", None)
        if gw is not None:
            if gw == 1:
                self._enter_victoria()
            else:
                self._enter_gameover()
            return

        self._start_new_rally()

    # ---------------------------
    # REINTENTAR / VOLVER
    # ---------------------------
    def _reiniciar_partida(self):
        # M√∫sica de juego (respetando mute)
        self._set_music_state("ingame")

        if self.score:
            if hasattr(self.score, "reset_match"):
                self.score.reset_match()
            else:
                self.score.reset_game()

        if hasattr(self.jugador1, "reset_position"):
            self.jugador1.reset_position()
        if hasattr(self.jugador2, "reset_position"):
            self.jugador2.reset_position()

        self._start_new_rally()
        self.estado_juego = 'jugando'
        self._restart_block_input = False  # liberar inputs

    def _volver_al_menu(self):
        self._set_music_state("menu")
        self.estado_juego = 'menu'

    # ---------------------------
    # Punto 4: Autowin de debug ‚Üí ‚Äú321 reiniciando partida‚Äù
    # ---------------------------
    def _start_debug_restart_countdown(self, ms=3000):
        if not self._restart_cd:
            # Fallback sin m√≥dulo: reinicio directo
            self._reiniciar_partida()
            return
        # Sin jingle ni cartel de victoria. Opcionalmente un whoosh suave.
        if "ui_whoosh" in self.audio.sounds:
            self.audio.play_sound("ui_whoosh")
        self._restart_block_input = True
        self._restart_cd.start(ms)

    # ---------------------------
    # Debug overlay: cajas de colisi√≥n de jugadores
    # ---------------------------
    def _draw_player_hitboxes(self, player, surface):
        try:
            from engine.config.collisions import COLOR_BODY, COLOR_RACKET
        except Exception:
            COLOR_BODY, COLOR_RACKET = (50, 220, 60), (240, 200, 40)

        if hasattr(player, "body_rect"):
            pygame.draw.rect(surface, COLOR_BODY, player.body_rect, width=2)
        if hasattr(player, "racket_rect"):
            pygame.draw.rect(surface, COLOR_RACKET, player.racket_rect, width=2)

--- FIN DE ARCHIVO: engine/game.py ---

--- INICIO DE ARCHIVO: engine/__init__.py ---

--- FIN DE ARCHIVO: engine/__init__.py ---

--- INICIO DE ARCHIVO: engine/menu.py ---
import pygame
from typing import Optional, Tuple, Dict, Any, List

try:
    # Colores y tama√±o de pantalla si existen en tu proyecto
    from engine.utils.colors import BLANCO
    from engine.utils.screen import ANCHO, ALTO
except Exception:
    BLANCO = (255, 255, 255)
    ANCHO, ALTO = 1280, 720  # fallback


class MenuScreen:
    """
    Men√∫ principal con selecci√≥n de modo 1P/2P.
    Integra audio UI si se provee un AudioManager (play_sound).

    Uso t√≠pico desde Game:
      self.menu = MenuScreen(self.PANTALLA, self.audio, current_mode=self.modo)
      self.menu.open()
      # en loop:
      action = self.menu.handle_event(evento)
      if action: self._on_menu_action(action)  # Game decide persistencia y modo
      self.menu.update(dt)
      self.menu.render()

    Donde _on_menu_action puede hacer:
      if action[0] == "start":
          self._set_mode(action[1]["mode"])   # "1P" o "2P" (Game persiste y aplica)
          self.estado_juego = "jugando"
          self._set_music_state("ingame")
          self._start_new_rally()
      elif action[0] == "options":
          self.estado_juego = "opciones"
      elif action[0] == "quit":
          pygame.event.post(pygame.event.Event(pygame.QUIT))
    """

    def __init__(self,
                 screen: pygame.Surface,
                 audio=None,
                 font_title: Optional[pygame.font.Font] = None,
                 font_item: Optional[pygame.font.Font] = None,
                 font_small: Optional[pygame.font.Font] = None,
                 current_mode: str = "1P"):
        self.screen = screen
        self.audio = audio

        # Fuentes
        self.font_title = font_title or pygame.font.Font(None, 64)
        self.font_item  = font_item  or pygame.font.Font(None, 44)
        self.font_small = font_small or pygame.font.Font(None, 28)

        # √çtems del men√∫ (texto, acci√≥n, payload opcional)
        self.items: List[Tuple[str, str, Dict[str, Any]]] = [
            ("1 Jugador",   "start",   {"mode": "1P"}),
            ("2 Jugadores", "start",   {"mode": "2P"}),
            ("Opciones",    "options", {}),
            ("Salir",       "quit",    {}),
        ]
        self.index = 0
        self._opened = False

        # Efecto visual simple
        self._sel_tick = 0.0

        # Modo actual (lo refleja en el footer)
        self.current_mode = (current_mode or "1P").upper()
        if self.current_mode not in ("1P", "2P"):
            self.current_mode = "1P"

        # Tips / ayuda en pantalla
        self.footer_lines: List[str] = [
            "‚Üë/‚Üì para moverte ¬∑ Enter para seleccionar ¬∑ Esc para salir",
            "Atajo r√°pido: 1 ‚Üí 1 Jugador | 2 ‚Üí 2 Jugadores",
        ]

    # -------- API para sincronizar desde Game --------
    def set_current_mode(self, mode: str):
        """Permite que Game actualice el modo mostrado en el men√∫."""
        m = (mode or "").upper()
        if m in ("1P", "2P"):
            self.current_mode = m

    # --------------- Ciclo de vida ---------------
    def open(self):
        self._opened = True
        self.index = 0
        self._sel_tick = 0.0

    def close(self):
        self._opened = False

    # --------------- Entrada ---------------
    def handle_event(self, event: pygame.event.Event) -> Optional[Tuple[str, Dict[str, Any]]]:
        if not self._opened:
            return None

        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_UP, pygame.K_w):
                self._move(-1)
            elif event.key in (pygame.K_DOWN, pygame.K_s):
                self._move(+1)
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                return self._select()
            elif event.key == pygame.K_ESCAPE:
                self._play("ui_back")
                return ("quit", {})
            # Atajos de modo
            elif event.key == pygame.K_1:
                return self._select_direct("1P")
            elif event.key == pygame.K_2:
                return self._select_direct("2P")

        return None

    def _move(self, delta: int):
        self.index = (self.index + delta) % len(self.items)
        self._play("ui_move")

    def _select(self) -> Tuple[str, Dict[str, Any]]:
        text, action, payload = self.items[self.index]
        self._play("ui_select")
        return (action, payload)

    def _select_direct(self, mode: str) -> Tuple[str, Dict[str, Any]]:
        # Devuelve directamente acci√≥n start con el modo forzado
        self._play("ui_select")
        return ("start", {"mode": mode})

    def _play(self, key: str):
        if self.audio and hasattr(self.audio, "play_sound"):
            try:
                self.audio.play_sound(key)
            except Exception:
                pass

    # --------------- L√≥gica ---------------
    def update(self, dt_ms: int):
        if not self._opened:
            return
        # Animaci√≥n simple para el selector
        self._sel_tick = (self._sel_tick + dt_ms / 1000.0) % 1.0

    # --------------- Dibujo ---------------
    def render(self):
        if not self._opened:
            return

        cx = ANCHO // 2
        # T√≠tulo
        title_surf = self.font_title.render("Tennis Isom√©trico", True, BLANCO)
        self.screen.blit(title_surf, title_surf.get_rect(center=(cx, 140)))

        # Items
        base_y = 260
        gap = 60
        for i, (text, _action, payload) in enumerate(self.items):
            sel = (i == self.index)
            label = f"> {text} <" if sel else f"  {text}  "
            surf = self.font_item.render(label, True, BLANCO)
            self.screen.blit(surf, surf.get_rect(center=(cx, base_y + i * gap)))

            # Subtexto del modo (para 1P/2P)
            if _action == "start" and "mode" in payload:
                mode = payload["mode"]
                subtitle = "(contra IA)" if mode == "1P" else "(dos jugadores locales)"
                sub = self.font_small.render(subtitle, True, BLANCO)
                self.screen.blit(sub, sub.get_rect(center=(cx, base_y + i * gap + 28)))

        # Footer / ayuda
        fy = base_y + gap * len(self.items) + 36
        # L√≠nea din√°mica: muestra el modo actual
        current_line = f"Modo actual: {self.current_mode}"
        s0 = self.font_small.render(current_line, True, BLANCO)
        self.screen.blit(s0, s0.get_rect(center=(cx, fy)))
        fy += 26

        for line in self.footer_lines:
            s = self.font_small.render(line, True, BLANCO)
            self.screen.blit(s, s.get_rect(center=(cx, fy)))
            fy += 26

        # Indicador animado (peque√±o brillo debajo del item seleccionado)
        sel_y = base_y + self.index * gap + 20
        w = int(180 + 20 * (0.5 - abs(self._sel_tick - 0.5)))  # respira
        glow = pygame.Surface((w, 6), pygame.SRCALPHA)
        glow.fill((255, 255, 255, 90))
        self.screen.blit(glow, glow.get_rect(center=(cx, sel_y + 30)))


# ----------- Helper opcional -----------
def run_standalone():
    """
    Permite probar el men√∫ de forma aislada:
      python -m engine.menu
    """
    pygame.init()
    screen = pygame.display.set_mode((ANCHO, ALTO))
    clock = pygame.time.Clock()
    menu = MenuScreen(screen, audio=None, current_mode="1P")
    menu.open()

    running = True
    while running:
        dt = clock.tick(60)
        for e in pygame.event.get():
            if e.type == pygame.QUIT:
                running = False
            else:
                action = menu.handle_event(e)
                if action:
                    print("[Menu action]", action)
                    if action[0] == "start" and "mode" in action[1]:
                        # reflejar en UI el modo elegido (en tu Game real, hac√©s _set_mode)
                        menu.set_current_mode(action[1]["mode"])
                    if action[0] == "quit":
                        running = False

        screen.fill((20, 30, 50))
        menu.update(dt)
        menu.render()
        pygame.display.flip()

    pygame.quit()


if __name__ == "__main__":
    run_standalone()

--- FIN DE ARCHIVO: engine/menu.py ---

--- INICIO DE ARCHIVO: engine/net.py ---
import pygame
import os
from engine.ball import world_to_iso
from engine.utils.screen import ALTO, ANCHO, SCALE, world_to_screen, to_pixels

NET_OFFSET = 100.0

class Net:
    def __init__(self, field, color=(255, 0, 0)):
        self.field = field
        self.color = color
        self.height = 1.0  # Altura de la red en unidades de mundo
        self.rect = None
        self.world_line = None
        self.debug = False  # nuevo flag para activar prints si se requiere

        self.width = field.width  # ancho de la cancha
        self.x = field.width / 2  # centro de la red en X
        self.y = (self.field.height / 2) + NET_OFFSET

        # Cargar textura
        texture_path = os.path.join("assets", "texturas", "red.png")
        try:
            self.texture = pygame.image.load(texture_path).convert_alpha()
        except Exception as e:
            print(f"[Net] No se pudo cargar la textura de la red: {e}")
            self.texture = None

    def update(self):
         # Desplazamiento l√≥gico hacia jugador 1
        # ajustar este valor para moveer la red adelante o atr√°s
        net_y = (self.field.height / 2) + NET_OFFSET
        self.y = net_y

        # L√≠nea base de colisi√≥n
        self.world_line = ((0, net_y), (self.field.width, net_y))
        self.rect = pygame.Rect(0, net_y - self.height / 2, self.field.width, self.height)

        print("Rect red l√≥gica:", self.rect)
        print("L√≠nea red debug:", self.world_line)

    def draw_debug(self, screen):
        """Dibuja el √°rea de colisi√≥n de la red para depuraci√≥n."""
        color = (255, 0, 0)  # rojo para debug

        # Asumimos que la red est√° centrada en el eje Y del campo (y = 0)
        # y ocupa una anchura fija (en coordenadas del mundo)
        NET_WIDTH = self.width
        NET_HEIGHT = self.height
        NET_Y = self.y  # posici√≥n base en el eje Y

        # Convertimos los puntos del rect√°ngulo a coordenadas isom√©tricas
        corners = [
            (0, NET_Y, 0),
            (NET_WIDTH, NET_Y, 0),
            (NET_WIDTH, NET_Y, NET_HEIGHT),
            (0, NET_Y, NET_HEIGHT),
        ]

        iso_points = [world_to_iso(x, y, z) for x, y, z in corners]
        iso_points = [(ix + ANCHO // 2, iy + ALTO // 3) for ix, iy in iso_points]

        # Dibujamos el contorno del √°rea de colisi√≥n
        pygame.draw.polygon(screen, color, iso_points, width=2)



    def update_net(self, court_rect):
        """Actualiza el rect de la red centrado en la cancha."""
        net_w = max(4, int(court_rect.width * 0.008))
        net_h = court_rect.height
        net_x = court_rect.centerx - net_w // 2
        net_y = court_rect.y
        self.rect = pygame.Rect(net_x, net_y, net_w, net_h)

        if self.debug:
            print(f"[Net] update_net(): rect={self.rect}")

    def draw(self, screen):
        """Dibuja la red (con textura si existe, o fallback s√≥lido)."""
        if not self.rect:
            return

        if self.texture:
            tw, th = self.texture.get_size()
            scale_factor = self.rect.height / th
            new_w = int(tw * scale_factor)
            new_h = int(th * scale_factor)
            scaled = pygame.transform.smoothscale(self.texture, (new_w, new_h))
            rect = scaled.get_rect(center=self.rect.center)
            screen.blit(scaled, rect)
        else:
            pygame.draw.rect(screen, (255, 0, 0), self.rect)

    def ball_hits_net(self, ball_pos, ball_radius):
        """
        Determina si la pelota colisiona con la red (en espacio de mundo).
        ball_pos: (x, y, z)
        ball_radius: radio de la pelota
        """
        bx, by, bz = ball_pos
        NET_OFFSET = 100.0  # mismo valor que arriba
        net_y = (self.field.height / 2) + NET_OFFSET

        net_height = self.height * 50  # altura l√≥gica

        near_net = abs(by - net_y) < ball_radius
        low_enough = bz <= net_height

        if near_net and low_enough:
            print(f"üí• Pelota impacta la red! (by={by:.1f}, net_y={net_y:.1f}, z={bz:.1f})")
            return True
        return False

--- FIN DE ARCHIVO: engine/net.py ---

--- INICIO DE ARCHIVO: engine/player.py ---
import os
import math
import random
import pygame
from engine.game_object import GameObject
from engine.utils.screen import screen_to_world, world_to_screen  # proyecci√≥n isom√©trica

# ‚öôÔ∏è par√°metros tunables centralizados (colisiones)
try:
    from engine.config.collisions import (
        BODY_W_SCALE, BODY_H_SCALE, BODY_Y_OFFSET,
        RACKET_W_SCALE, RACKET_H_SCALE, RACKET_Y_OFFSET
    )
except Exception:
    BODY_W_SCALE, BODY_H_SCALE, BODY_Y_OFFSET = 0.55, 0.80, 4
    RACKET_W_SCALE, RACKET_H_SCALE, RACKET_Y_OFFSET = 0.40, 0.28, -6

# ‚öôÔ∏è controles de golpe
try:
    from engine.config.controls import KEY_FLAT, KEY_TOPSPIN, KEY_SLICE
except Exception:
    KEY_FLAT, KEY_TOPSPIN, KEY_SLICE = pygame.K_SPACE, pygame.K_z, pygame.K_x

# ‚öôÔ∏è f√≠sica de spin
try:
    from engine.config.physics import SPIN_TOPSPIN, SPIN_SLICE, SPIN_FLAT
except Exception:
    SPIN_TOPSPIN, SPIN_SLICE, SPIN_FLAT = +0.9, -0.7, 0.0


def _clamp(v, lo, hi):
    return max(lo, min(hi, v))


class Player(GameObject):
    """
    Player con:
    - Input isom√©trico (‚Üë‚Üì‚Üê‚Üí => diagonales de mundo)
    - Sprint (Shift) y Walk (Ctrl)
    - Dos cajas (cuerpo + raqueta) tunables v√≠a engine/config/collisions.py
    - Golpe direccional + hit flash y selecci√≥n de efecto (flat/topspin/slice)
    - Animator con FPS adaptables (si existe)
    """

    def __init__(self, x, y, field, jugador2=False, game=None):
        json_path = os.path.join('assets', 'sprites', 'player_animation', 'player.json')
        super().__init__(x, y, json_path=json_path)

        self.world_x = float(x)
        self.world_y = float(y)
        self.field = field
        self.is_player2 = jugador2
        self.game = game

        # Velocidad base + modificadores
        self.base_speed = 8.0
        self.sprint_mult = 1.35
        self.walk_mult = 0.60

        # Animator (si existe) ajusta FPS de caminata
        self._walk_fps_sprint = 14
        self._walk_fps_normal = 10
        self._walk_fps_slow = 7

        self._last_ix = 0.0
        self._last_iy = 0.0

        self.swing_active = False
        self.swing_timer = 0
        self.swing_duration = 600  # milisegundos de ventana para golpear

        self.swing_duration = 400    # ms (duraci√≥n efectiva del golpe)
        self.swing_delay = 250        # ms antes del impacto real (ajustable)
        self.swing_cooldown = 600     # ms antes de poder iniciar otro golpe
        self.swing_start_time = 0     # tiempo en que se inici√≥ el swing
        self.swing_state = "ready"    # "ready", "charging", "swinging", "cooldown"
        self.pending_direction = None # direcci√≥n elegida durante el delay

        # Golpe actual (se setea en mover() leyendo teclas)
        self._shot_mode = "flat"   # "flat" | "topspin" | "slice"

        if not self.rect:
            self.rect = pygame.Rect(self.world_x, self.world_y, 32, 48)

        # Cajas
        self.racket_rect = self.rect.copy()
        self._update_collision_boxes()


        #Colision del jugador
        self.hit_rect = self.rect.copy()
        self.hit_rect.width = self.rect.width * 0.4 #40% del ancho original
        self.hit_rect.height = self.rect.height * 0.6 # 60% del alto original
        self.hit_rect.center = self.rect.center

        #Colision de la raqueta
        self.racket_active = False
        self.racket_width = self.rect.width // 2
        self.racket_height = self.rect.height // 1.3
        self.racket_offset_x = self.rect.width // 3
        self.racket_offset_y = 0
        self.racket_rect = pygame.Rect(0, 0, self.racket_width, self.racket_height)

        # --- Estado del jugador --- 
        self.estado = "idle" 
        self.direccion1 = "right" 
        self.direccion2 = "right" 
        self.anim_timer = 0 
        self.frame_index = 0


        # Animaci√≥n inicial
        if self.is_player2 and "idle-P2" in self.animations:
            self.current_animation = "idle-P2"
        elif "idle" in self.animations:
            self.current_animation = "idle"
        self.frame_index = 0

        # Swing / flash
        self._swing_cd_ms = 160
        self._last_swing = -10**9
        self._hit_flash_active = False
        self._hit_flash_start = 0
        self._hit_flash_duration = 600  # ms
        self.target_zone = random.choice(["deep_back_left", "back_left", "deep_front_left", "front_left",
                                        "deep_front_right", "front_right", "deep_back_right", "back_right"])

        # --- Estados de saque --- 
        self.is_serving = False # Si est√° en modo de saque 
        self.serve_stage = None # "toss" o "hit" 
        self.serve_start_time = 0 
        self.serve_duration_toss = 1600 # ms (duraci√≥n del lanzamiento) 
        self.serve_duration_hit = 900 # ms (duraci√≥n del golpe) 
        self.can_serve = True # si puede iniciar un saque (luego lo controla el juego)

        self._project_to_screen()


    def update_racket(self): 
        # Determinar offset horizontal seg√∫n direcci√≥n y golpe
        if self.is_player2:
            mirando = self.direccion2
        else:
            mirando = self.direccion1

        # Distancia base desde el cuerpo
        base_offset = self.racket_offset_x

        # Si est√° golpeando, movemos m√°s la raqueta hacia afuera
        if self.estado == "golpeando":
            base_offset *= 1.6   # reach aumentado pero razonable
            # Seguridad extra: limitar el reach si alguien lo re-tunea
            base_offset = max(min(base_offset, 2.0), 0.8)

        # Aplicar direcci√≥n
        if mirando == "right":
            offset_x = abs(base_offset)
        else:
            offset_x = -abs(base_offset)

        # Actualizar posici√≥n de la hitbox
        self.racket_rect.centerx = self.rect.centerx + offset_x
        self.racket_rect.centery = self.rect.centery + self.racket_offset_y
        """
        # Determinar offset horizontal seg√∫n direcci√≥n 
        if (self.is_player2 and self.direccion2 == "right") or (not self.is_player2 and self.direccion1 == "right"):
            offset_x = abs(self.racket_offset_x) 
        else: 
            offset_x = -abs(self.racket_offset_x) 
            
        self.racket_rect.centerx = self.rect.centerx + offset_x 
        self.racket_rect.top = self.rect.top + self.racket_offset_y
        """
    # ---------------------------
    # Helpers internos
    # ---------------------------
    def _project_to_screen(self):
        if not self.rect:
            return
        iso_x, iso_y = world_to_screen(self.world_x, self.world_y)
        self.rect.center = (iso_x, iso_y)
        self._update_collision_boxes()

    def _update_collision_boxes(self):
        w, h = self.rect.width, self.rect.height

        # cuerpo
        body_w = max(8, int(w * BODY_W_SCALE))
        body_h = max(8, int(h * BODY_H_SCALE))
        body = pygame.Rect(0, 0, body_w, body_h)
        body.centerx = self.rect.centerx
        body.bottom  = self.rect.bottom - BODY_Y_OFFSET
        self.body_rect = body

        # raqueta
        rw = max(4, int(w * RACKET_W_SCALE))
        rh = max(4, int(h * RACKET_H_SCALE))
        racket = pygame.Rect(0, 0, rw, rh)

        # --- üîÅ Offset lateral din√°mico seg√∫n direcci√≥n ---
        if self.is_player2:
            mirando = getattr(self, "direccion2", "right")
        else:
            mirando = getattr(self, "direccion1", "right")

        # desplazamiento lateral (en px)
        offset_x = int(w * 0.3)  # pod√©s ajustar 0.3 ‚Üí cuanto m√°s grande, m√°s se separa del cuerpo

        if mirando == "left":
            racket.centerx = self.rect.centerx - offset_x
        else:
            racket.centerx = self.rect.centerx + offset_x

        racket.top = self.rect.top + RACKET_Y_OFFSET
        self.racket_rect = racket

    def _play_swing(self):
        now = pygame.time.get_ticks()
        if (now - self._last_swing) >= self._swing_cd_ms:
            if "swing" in self.animations:
                self.current_animation = "swing"
                self.frame_index = 0
            self._last_swing = now

    def _tune_walk_fps(self, mode: str):
        animator = getattr(self, "_animator", None)
        if not animator or not hasattr(animator, "set_fps"):
            return
        fps = self._walk_fps_normal
        if mode == "sprint":
            fps = self._walk_fps_sprint
        elif mode == "slow":
            fps = self._walk_fps_slow
        for name in (
            "walk-left", "walk-right", "walk-up", "walk-down",
            "walk-left-P2", "walk-right-P2", "walk-up-P2", "walk-down-P2",
        ):
            if name in self.animations:
                animator.set_fps(name, fps)

    # ---------------------------
    # Movimiento (+ leer teclas de golpe)
    # ---------------------------
    def mover(self, teclas):
        moved = False
        current_time = pygame.time.get_ticks()

        # --- BLOQUEAR movimiento y animaciones si est√° en modo saque ---
        if getattr(self, "is_serving", False):
            # No mover ni sobreescribir animaciones durante el saque
            return
        # =========================
        # CONTROL DE SWING / GOLPE
        # =========================
        # 1Ô∏è‚É£ Si est√° en cooldown, verificar si termin√≥
        if hasattr(self, "swing_state") and self.swing_state == "cooldown":
            if current_time - self.swing_start_time >= self.swing_cooldown:
                self.swing_state = "ready"

        # 2Ô∏è‚É£ Si est√° golpeando, verificar si termin√≥ la animaci√≥n
        if hasattr(self, "swing_state") and self.swing_state == "swinging":
            if current_time - self.swing_start_time >= self.swing_duration:
                # Fin del golpe ‚Üí pasar a cooldown
                self.swing_state = "cooldown"
                self.estado = "idle"
                self.racket_active = False
                self.swing_active = False
                self.current_animation = "idle-P2" if self.is_player2 else "idle"
            else:
                # Todav√≠a golpeando ‚Üí bloquear movimiento
                return  # üö´ no mover durante el golpe

        # 3Ô∏è‚É£ Detectar intento de golpe (solo si est√° listo)
        if hasattr(self, "swing_state") and self.swing_state == "ready":
            if self.is_player2:
                k_swing = pygame.K_f
                k_left, k_right, k_up = pygame.K_a, pygame.K_d, pygame.K_s
            else:
                k_swing = pygame.K_SPACE
                k_left, k_right, k_up = pygame.K_LEFT, pygame.K_RIGHT, pygame.K_UP

            if teclas[k_swing]:
                self.swing_state = "swinging"
                self.swing_start_time = current_time
                self.racket_active = True
                self.swing_active = True
                self.estado = "golpeando"
                
                print("üè∏ Golpe iniciado")

                # ============================
                # 1Ô∏è‚É£ Determinar direcci√≥n visual
                # ============================
                ball = getattr(self.game, "_ball_main", None)
                if ball:
                    player_x_screen, y_screen = world_to_screen(self.world_x, self.world_y)
                    if ball.screen_x < player_x_screen:
                        if self.is_player2:
                            self.direccion2 = "left"
                        else:
                            self.direccion1 = "left"
                    else:
                        if self.is_player2:
                            self.direccion2 = "right"
                        else:
                            self.direccion1 = "right"

                # ============================
                # 2Ô∏è‚É£ Elegir zona de golpe seg√∫n entrada
                # ============================
                press_left  = teclas[k_left]
                press_right = teclas[k_right]
                press_up    = teclas[k_up]
                
                if self.is_player2:
                    if press_left and press_up:
                        self.pending_direction = "deep_back_left"
                    elif press_right and press_up:
                        self.pending_direction = "deep_back_right"
                    elif press_left:
                        self.pending_direction = "back_left"
                    elif press_right:
                        self.pending_direction = "back_right"
                    elif press_up:
                        self.pending_direction =  random.choice(["deep_back_left", "deep_back_right"])
                    else:
                        self.pending_direction = "center_back"
                else:
                    if press_left and press_up:
                        self.pending_direction = "deep_front_left"
                    elif press_right and press_up:
                        self.pending_direction = "deep_front_right"
                    elif press_left:
                        self.pending_direction = "front_left"
                    elif press_right:
                        self.pending_direction = "front_right"
                    elif press_up:
                        self.pending_direction = random.choice(["deep_front_left", "deep_front_right"])
                    else:
                        self.pending_direction = "center_front"

                print(f"üéØ Direcci√≥n elegida: {self.pending_direction}")

                # ============================
                # 3Ô∏è‚É£ Animaci√≥n de golpe
                # ============================
                if self.is_player2:
                    self.current_animation = "stroke-left-P2" if self.direccion2 == "left" else "stroke-right-P2"
                else:
                    self.current_animation = "stroke-left" if self.direccion1 == "left" else "stroke-right"

                self.frame_index = 0
                self.anim_timer = 0
                return  # üö´ no mover durante el golpe


        # =========================
        # MOVIMIENTO NORMAL
        # =========================
        if self.is_player2:
            k_left, k_right, k_up, k_down = pygame.K_a, pygame.K_d, pygame.K_w, pygame.K_s
        else:
            k_left, k_right, k_up, k_down = pygame.K_LEFT, pygame.K_RIGHT, pygame.K_UP, pygame.K_DOWN

        press_up    = bool(teclas[k_up])
        press_down  = bool(teclas[k_down])
        press_left  = bool(teclas[k_left])
        press_right = bool(teclas[k_right])

        press_shift = bool(teclas[pygame.K_LSHIFT] or teclas[pygame.K_RSHIFT])
        press_ctrl  = bool(teclas[pygame.K_LCTRL]  or teclas[pygame.K_RCTRL])

        if press_shift:
            speed = self.base_speed * self.sprint_mult
            self._tune_walk_fps("sprint")
        elif press_ctrl:
            speed = self.base_speed * self.walk_mult
            self._tune_walk_fps("slow")
        else:
            speed = self.base_speed
            self._tune_walk_fps("normal")

        # Mapeo isom√©trico
        dir_x = 0.0
        dir_y = 0.0
        if press_up:
            dx, dy = world_to_screen(-1, -1)
            dir_x += dx
            dir_y += dy
        if press_down:
            dx, dy = world_to_screen(1, 1)
            dir_x += dx
            dir_y += dy
        if press_left:
            dx, dy = world_to_screen(-1, 1)
            dir_x += dx
            dir_y += dy
        if press_right:
            dx, dy = world_to_screen(1, -1)
            dir_x += dx
            dir_y += dy

        # Normalizar movimiento
        if dir_x != 0 or dir_y != 0:
            length = math.hypot(dir_x, dir_y)
            dir_x /= length
            dir_y /= length
            self.world_x += dir_x * speed
            self.world_y += dir_y * speed
            moved = True

            # Animaciones direccionales
            use_up = abs(dir_y) >= abs(dir_x) and dir_y < 0
            use_down = abs(dir_y) >= abs(dir_x) and dir_y > 0
            if use_up and ("walk-up-P2" if self.is_player2 else "walk-up") in self.animations:
                self.current_animation = "walk-up-P2" if self.is_player2 else "walk-up"
            elif use_down and ("walk-down-P2" if self.is_player2 else "walk-down") in self.animations:
                self.current_animation = "walk-down-P2" if self.is_player2 else "walk-down"
            else:
                if dir_x < 0:
                    self.current_animation = "walk-left-P2" if (self.is_player2 and "walk-left-P2" in self.animations) else \
                                            ("walk-left" if "walk-left" in self.animations else self.current_animation)
                    if "walk-left-P2" in self.current_animation:
                        self.direccion2 = "left"
                    else:
                        self.direccion1 = "left"
                elif dir_x > 0:
                    self.current_animation = "walk-right-P2" if (self.is_player2 and "walk-right-P2" in self.animations) else \
                                            ("walk-right" if "walk-right" in self.animations else self.current_animation)
                    if "walk-right-P2" in self.current_animation:
                        self.direccion2 = "right"
                    else:
                        self.direccion1 = "right"
        else:
            self.current_animation = "idle-P2" if (self.is_player2 and "idle-P2" in self.animations) else \
                                    ("idle" if "idle" in self.animations else self.current_animation)

        # Limitar por la red
        if self.field and hasattr(self.field, "net_y"):
            net_y = float(self.field.net_y)
            if self.is_player2:
                if self.world_y > net_y - 1:
                    self.world_y = net_y - 1
            else:
                if self.world_y < net_y + 1:
                    self.world_y = net_y + 1

        # Avance de frame por movimiento
        if moved and self.current_animation in self.animations:
            self.frame_index = (self.frame_index + 1) % len(self.animations[self.current_animation])

        self._project_to_screen()

    def iniciar_saque(self):
        if getattr(self, "is_serving", False):
            return  # Ya est√° sirviendo, no reiniciar

        self.is_serving = True
        self.serve_stage = "toss"
        self.current_animation = "Saque-01-P2" if self.is_player2 else "Saque-01-P1"
        self.serve_start_time = pygame.time.get_ticks()
        self.serve_duration_toss = 600  # milisegundos aprox.
        print("üéæ Inicia saque (toss)")

    def realizar_saque(self):
        if self.serve_stage != "ready_for_hit":
            return  # A√∫n no termin√≥ el lanzamiento

        self.serve_stage = "hit"
        self.current_animation = "Saque-02-P2" if self.is_player2 else "Saque-02-P1"
        self.serve_start_time = pygame.time.get_ticks()
        self.serve_duration_hit = 400
        print("üí• Golpe de saque iniciado")

    def update(self):
        self._project_to_screen()
        # Llamar al update de GameObject si existe
        if not getattr(self, "is_serving", False):
            try:
                super().update()
            except Exception:
                pass
        # hit flash timeout
        if getattr(self, "is_serving", False):
            current_time = pygame.time.get_ticks()

            # --- Etapa 1: lanzamiento del saque ---
            if self.serve_stage == "toss":
                dur = getattr(self, "serve_duration_toss", 0)
                if current_time - self.serve_start_time >= dur:
                    self.serve_stage = "ready_for_hit"
                    print("‚è≥ Listo para golpe de saque")
                    # Quedarse en el √∫ltimo frame del toss
                    frames = self.animations.get(self.current_animation, [])
                    if frames:
                        self.frame_index = len(frames) - 1  # √∫ltimo frame
                    # Evitar que el animator la siga loopando
                    self.anim_timer = 0
                    return

            # --- Etapa 2: golpe del saque ---
            elif self.serve_stage == "hit":
                dur = getattr(self, "serve_duration_hit", 0)
                if current_time - self.serve_start_time >= dur:
                    # Fin del golpe ‚Üí volver a idle
                    self.is_serving = False
                    self.can_serve = False
                    self.serve_stage = None
                    self.current_animation = "idle-P2" if self.is_player2 else "idle"
                    print("‚úÖ Saque completo (una sola vez)")
                else:
                    # No reiniciar la animaci√≥n ‚Äî dejarla avanzar naturalmente
                    pass

    def draw(self, surface):
        if not self.sprite_sheet or not self.animations or not self.rect:
            return
        frames = self.animations.get(self.current_animation, [])
        if not frames:
            return
        self.frame_index %= len(frames)
        fx, fy, fw, fh = frames[self.frame_index]
        frame_surf = self.sprite_sheet.subsurface(pygame.Rect(fx, fy, fw, fh))

        if self._hit_flash_active:
            flash = frame_surf.copy()
            flash.fill((255, 255, 255, 70), special_flags=pygame.BLEND_RGBA_ADD)
            surface.blit(flash, self.rect)
        else:
            surface.blit(frame_surf, self.rect)

    # ---------------------------
    # Colisiones con pelota
    # ---------------------------
    def check_ball_collision(self, ball, tolerance=25):
        """Chequea si la pelota colisiona con la raqueta activa (USANDO COORDENADAS DE PANTALLA)."""
        if not self.racket_active:
            return False

        # Asegurarnos que ball.rect y las propiedades screen_x/screen_y est√©n actualizadas
        # (Ball.update() deber√≠a actualizar rect.center usando screen_x/screen_y)
        try:
            bx = int(getattr(ball, "screen_x"))
            by = int(getattr(ball, "screen_y"))
        except Exception:
            # fallback si no existen las propiedades
            bx = int(ball.rect.centerx)
            by = int(ball.rect.centery)

        r = getattr(ball, "radio", 10)
        ball_2d_rect = pygame.Rect(bx - r, by - r, r*2, r*2)

        # Debug: ver posiciones en pantalla
        if getattr(self, "_debug_collision", False):
            print(f"üìç [ISO] Player rect: {self.racket_rect} | Ball screen: ({bx},{by})")

        # Solo durante la fase de impacto
        if self.swing_state == "swinging":
            if ball_2d_rect.colliderect(self.racket_rect):
                print("üî• Colisi√≥n detectada entre raqueta y pelota!")

                # Determinar zona final
                if self.pending_direction:
                    zone = self.pending_direction
                else:
                    zone = random.choice(["deep_back_left", "back_left", "deep_front_left", "front_left",
                                        "deep_front_right", "front_right", "deep_back_right", "back_right"])

                # Pasamos la posici√≥n del jugador en MUNDO
                ball.hit_by_player((self.world_x, self.world_y), zone=self.pending_direction, is_player2=self.is_player2)
                print(f"üí• Golpe hacia zona: {zone}")

                # Finalizar swing inmediatamente despu√©s del impacto
                self.swing_state = "cooldown"
                self._last_swing = pygame.time.get_ticks()
                self.swing_active = False
                self.racket_active = False
                return True
            
        # debug de distancia (√∫til si quer√©s ajustar tolerancia)
        # calcular distancia en pantalla entre centros:
        dx = (self.racket_rect.centerx - bx)
        dy = (self.racket_rect.centery - by)
        dist = (dx*dx + dy*dy) ** 0.5
        # ajust√° tolerancia si quer√©s
        # print(f"üí® Sin colisi√≥n con pelota. Distancia pantalla={dist:.1f}, tolerancia=25")
        return False

--- FIN DE ARCHIVO: engine/player.py ---

--- INICIO DE ARCHIVO: engine/score.py ---
# Coloca esta clase en un archivo 'engine/score.py' y aseg√∫rate de importarla
# O, si no tienes un archivo separado, col√≥cala en 'engine/game.py'
class ScoreManager:
    """Gestiona la puntuaci√≥n de un juego de tenis (0, 15, 30, 40, Deuce, Adv, Game)."""

    # La puntuaci√≥n de tenis se mapea internamente a 0, 1, 2, 3 puntos.
    SCORES = {0: "0", 1: "15", 2: "30", 3: "40"}
    
    def __init__(self, player1_name="P1", player2_name="P2"):
        self.player1_name = player1_name
        self.player2_name = player2_name
        self.reset_game()
        
    def reset_game(self):
        """Reinicia la puntuaci√≥n de un juego."""
        self.p1_points = 0  # 0, 1, 2, 3...
        self.p2_points = 0
        self.game_winner = None # 'P1', 'P2', o None
        
    def point_for(self, winner: str):
        """Suma un punto al jugador ganador y verifica si se termina el juego."""
        if self.game_winner:
            return 

        if winner == self.player1_name:
            self.p1_points += 1
        elif winner == self.player2_name:
            self.p2_points += 1
        else:
            return

        self._check_game_end()
        
    def _check_game_end(self):
        p1 = self.p1_points
        p2 = self.p2_points
        
        # L√≥gica de Deuce/Ventaja
        if p1 >= 3 and p2 >= 3:
            diff = abs(p1 - p2)
            
            # Ganar el juego (2 puntos de ventaja despu√©s del 40-40)
            if diff >= 2:
                self.game_winner = self.player1_name if p1 > p2 else self.player2_name
            
        # Ganar el juego sin Deuce (ej: 40-0, 40-30)
        elif p1 >= 4:
            self.game_winner = self.player1_name
        elif p2 >= 4:
            self.game_winner = self.player2_name

    def get_score_str(self) -> str:
        """Devuelve la puntuaci√≥n actual en formato de texto (ej: "15-30" o "Advantage P1")."""
        if self.game_winner:
            return f"Game {self.game_winner}"

        p1 = self.p1_points
        p2 = self.p2_points
        
        # Caso Deuce / Ventaja
        if p1 >= 3 and p2 >= 3:
            if p1 == p2:
                return "Deuce"
            elif p1 > p2:
                return "Advantage P1"
            else:
                return "Advantage P2"
                
        # Puntuaci√≥n normal (0, 15, 30, 40)
        score1 = self.SCORES.get(p1, "40+")
        score2 = self.SCORES.get(p2, "40+")
        
        return f"{score1}-{score2}"

--- FIN DE ARCHIVO: engine/score.py ---

